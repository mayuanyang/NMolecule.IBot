{"version":3,"names":[],"mappings":"","sources":["ui-bootstrap-tpls.js"],"sourcesContent":["/*\r\n * angular-ui-bootstrap\r\n * http://angular-ui.github.io/bootstrap/\r\n\r\n * Version: 1.3.3 - 2016-05-22\r\n * License: MIT\r\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\r\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/backdrop.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\r\nangular.module('ui.bootstrap.collapse', [])\r\n\r\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\r\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\r\n    return {\r\n      link: function(scope, element, attrs) {\r\n        var expandingExpr = $parse(attrs.expanding),\r\n            expandedExpr = $parse(attrs.expanded),\r\n            collapsingExpr = $parse(attrs.collapsing),\r\n            collapsedExpr = $parse(attrs.collapsed);\r\n\r\n        if (!scope.$eval(attrs.uibCollapse)) {\r\n          element.addClass('in')\r\n            .addClass('collapse')\r\n            .attr('aria-expanded', true)\r\n            .attr('aria-hidden', false)\r\n            .css({height: 'auto'});\r\n        }\r\n\r\n        function expand() {\r\n          if (element.hasClass('collapse') && element.hasClass('in')) {\r\n            return;\r\n          }\r\n\r\n          $q.resolve(expandingExpr(scope))\r\n            .then(function() {\r\n              element.removeClass('collapse')\r\n                .addClass('collapsing')\r\n                .attr('aria-expanded', true)\r\n                .attr('aria-hidden', false);\r\n\r\n              if ($animateCss) {\r\n                $animateCss(element, {\r\n                  addClass: 'in',\r\n                  easing: 'ease',\r\n                  to: { height: element[0].scrollHeight + 'px' }\r\n                }).start()['finally'](expandDone);\r\n              } else {\r\n                $animate.addClass(element, 'in', {\r\n                  to: { height: element[0].scrollHeight + 'px' }\r\n                }).then(expandDone);\r\n              }\r\n            });\r\n        }\r\n\r\n        function expandDone() {\r\n          element.removeClass('collapsing')\r\n            .addClass('collapse')\r\n            .css({height: 'auto'});\r\n          expandedExpr(scope);\r\n        }\r\n\r\n        function collapse() {\r\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\r\n            return collapseDone();\r\n          }\r\n\r\n          $q.resolve(collapsingExpr(scope))\r\n            .then(function() {\r\n              element\r\n                // IMPORTANT: The height must be set before adding \"collapsing\" class.\r\n                // Otherwise, the browser attempts to animate from height 0 (in\r\n                // collapsing class) to the given height here.\r\n                .css({height: element[0].scrollHeight + 'px'})\r\n                // initially all panel collapse have the collapse class, this removal\r\n                // prevents the animation from jumping to collapsed state\r\n                .removeClass('collapse')\r\n                .addClass('collapsing')\r\n                .attr('aria-expanded', false)\r\n                .attr('aria-hidden', true);\r\n\r\n              if ($animateCss) {\r\n                $animateCss(element, {\r\n                  removeClass: 'in',\r\n                  to: {height: '0'}\r\n                }).start()['finally'](collapseDone);\r\n              } else {\r\n                $animate.removeClass(element, 'in', {\r\n                  to: {height: '0'}\r\n                }).then(collapseDone);\r\n              }\r\n            });\r\n        }\r\n\r\n        function collapseDone() {\r\n          element.css({height: '0'}); // Required so that collapse works when animation is disabled\r\n          element.removeClass('collapsing')\r\n            .addClass('collapse');\r\n          collapsedExpr(scope);\r\n        }\r\n\r\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\r\n          if (shouldCollapse) {\r\n            collapse();\r\n          } else {\r\n            expand();\r\n          }\r\n        });\r\n      }\r\n    };\r\n  }]);\r\n\r\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])\r\n\r\n.constant('uibAccordionConfig', {\r\n  closeOthers: true\r\n})\r\n\r\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\r\n  // This array keeps track of the accordion groups\r\n  this.groups = [];\r\n\r\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\r\n  this.closeOthers = function(openGroup) {\r\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\r\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\r\n    if (closeOthers) {\r\n      angular.forEach(this.groups, function(group) {\r\n        if (group !== openGroup) {\r\n          group.isOpen = false;\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  // This is called from the accordion-group directive to add itself to the accordion\r\n  this.addGroup = function(groupScope) {\r\n    var that = this;\r\n    this.groups.push(groupScope);\r\n\r\n    groupScope.$on('$destroy', function(event) {\r\n      that.removeGroup(groupScope);\r\n    });\r\n  };\r\n\r\n  // This is called from the accordion-group directive when to remove itself\r\n  this.removeGroup = function(group) {\r\n    var index = this.groups.indexOf(group);\r\n    if (index !== -1) {\r\n      this.groups.splice(index, 1);\r\n    }\r\n  };\r\n}])\r\n\r\n// The accordion directive simply sets up the directive controller\r\n// and adds an accordion CSS class to itself element.\r\n.directive('uibAccordion', function() {\r\n  return {\r\n    controller: 'UibAccordionController',\r\n    controllerAs: 'accordion',\r\n    transclude: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\r\n    }\r\n  };\r\n})\r\n\r\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\r\n.directive('uibAccordionGroup', function() {\r\n  return {\r\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\r\n    transclude: true,              // It transcludes the contents of the directive into the template\r\n    replace: true,                // The element containing the directive will be replaced with the template\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\r\n    },\r\n    scope: {\r\n      heading: '@',               // Interpolate the heading attribute onto this scope\r\n      panelClass: '@?',           // Ditto with panelClass\r\n      isOpen: '=?',\r\n      isDisabled: '=?'\r\n    },\r\n    controller: function() {\r\n      this.setHeading = function(element) {\r\n        this.heading = element;\r\n      };\r\n    },\r\n    link: function(scope, element, attrs, accordionCtrl) {\r\n      accordionCtrl.addGroup(scope);\r\n\r\n      scope.openClass = attrs.openClass || 'panel-open';\r\n      scope.panelClass = attrs.panelClass || 'panel-default';\r\n      scope.$watch('isOpen', function(value) {\r\n        element.toggleClass(scope.openClass, !!value);\r\n        if (value) {\r\n          accordionCtrl.closeOthers(scope);\r\n        }\r\n      });\r\n\r\n      scope.toggleOpen = function($event) {\r\n        if (!scope.isDisabled) {\r\n          if (!$event || $event.which === 32) {\r\n            scope.isOpen = !scope.isOpen;\r\n          }\r\n        }\r\n      };\r\n\r\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\r\n      scope.headingId = id + '-tab';\r\n      scope.panelId = id + '-panel';\r\n    }\r\n  };\r\n})\r\n\r\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\r\n.directive('uibAccordionHeading', function() {\r\n  return {\r\n    transclude: true,   // Grab the contents to be used as the heading\r\n    template: '',       // In effect remove this element!\r\n    replace: true,\r\n    require: '^uibAccordionGroup',\r\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\r\n      // Pass the heading to the accordion-group controller\r\n      // so that it can be transcluded into the right place in the template\r\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\r\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\r\n    }\r\n  };\r\n})\r\n\r\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\r\n// You must provide the property on the accordion-group controller that will hold the transcluded element\r\n.directive('uibAccordionTransclude', function() {\r\n  return {\r\n    require: '^uibAccordionGroup',\r\n    link: function(scope, element, attrs, controller) {\r\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\r\n        if (heading) {\r\n          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));\r\n          elem.html('');\r\n          elem.append(heading);\r\n        }\r\n      });\r\n    }\r\n  };\r\n\r\n  function getHeaderSelectors() {\r\n      return 'uib-accordion-header,' +\r\n          'data-uib-accordion-header,' +\r\n          'x-uib-accordion-header,' +\r\n          'uib\\\\:accordion-header,' +\r\n          '[uib-accordion-header],' +\r\n          '[data-uib-accordion-header],' +\r\n          '[x-uib-accordion-header]';\r\n  }\r\n});\r\n\r\nangular.module('ui.bootstrap.alert', [])\r\n\r\n.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {\r\n  $scope.closeable = !!$attrs.close;\r\n\r\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\r\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\r\n\r\n  if (dismissOnTimeout) {\r\n    $timeout(function() {\r\n      $scope.close();\r\n    }, parseInt(dismissOnTimeout, 10));\r\n  }\r\n}])\r\n\r\n.directive('uibAlert', function() {\r\n  return {\r\n    controller: 'UibAlertController',\r\n    controllerAs: 'alert',\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\r\n    },\r\n    transclude: true,\r\n    replace: true,\r\n    scope: {\r\n      type: '@',\r\n      close: '&'\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.buttons', [])\r\n\r\n.constant('uibButtonConfig', {\r\n  activeClass: 'active',\r\n  toggleEvent: 'click'\r\n})\r\n\r\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\r\n  this.activeClass = buttonConfig.activeClass || 'active';\r\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\r\n}])\r\n\r\n.directive('uibBtnRadio', ['$parse', function($parse) {\r\n  return {\r\n    require: ['uibBtnRadio', 'ngModel'],\r\n    controller: 'UibButtonsController',\r\n    controllerAs: 'buttons',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\r\n\r\n      element.find('input').css({display: 'none'});\r\n\r\n      //model -> UI\r\n      ngModelCtrl.$render = function() {\r\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\r\n      };\r\n\r\n      //ui->model\r\n      element.on(buttonsCtrl.toggleEvent, function() {\r\n        if (attrs.disabled) {\r\n          return;\r\n        }\r\n\r\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\r\n\r\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\r\n          scope.$apply(function() {\r\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\r\n            ngModelCtrl.$render();\r\n          });\r\n        }\r\n      });\r\n\r\n      if (attrs.uibUncheckable) {\r\n        scope.$watch(uncheckableExpr, function(uncheckable) {\r\n          attrs.$set('uncheckable', uncheckable ? '' : undefined);\r\n        });\r\n      }\r\n    }\r\n  };\r\n}])\r\n\r\n.directive('uibBtnCheckbox', function() {\r\n  return {\r\n    require: ['uibBtnCheckbox', 'ngModel'],\r\n    controller: 'UibButtonsController',\r\n    controllerAs: 'button',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n      element.find('input').css({display: 'none'});\r\n\r\n      function getTrueValue() {\r\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\r\n      }\r\n\r\n      function getFalseValue() {\r\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\r\n      }\r\n\r\n      function getCheckboxValue(attribute, defaultValue) {\r\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\r\n      }\r\n\r\n      //model -> UI\r\n      ngModelCtrl.$render = function() {\r\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\r\n      };\r\n\r\n      //ui->model\r\n      element.on(buttonsCtrl.toggleEvent, function() {\r\n        if (attrs.disabled) {\r\n          return;\r\n        }\r\n\r\n        scope.$apply(function() {\r\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\r\n          ngModelCtrl.$render();\r\n        });\r\n      });\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.carousel', [])\r\n\r\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\r\n  var self = this,\r\n    slides = self.slides = $scope.slides = [],\r\n    SLIDE_DIRECTION = 'uib-slideDirection',\r\n    currentIndex = $scope.active,\r\n    currentInterval, isPlaying, bufferedTransitions = [];\r\n\r\n  var destroyed = false;\r\n\r\n  self.addSlide = function(slide, element) {\r\n    slides.push({\r\n      slide: slide,\r\n      element: element\r\n    });\r\n    slides.sort(function(a, b) {\r\n      return +a.slide.index - +b.slide.index;\r\n    });\r\n    //if this is the first slide or the slide is set to active, select it\r\n    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\r\n      if ($scope.$currentTransition) {\r\n        $scope.$currentTransition = null;\r\n      }\r\n\r\n      currentIndex = slide.index;\r\n      $scope.active = slide.index;\r\n      setActive(currentIndex);\r\n      self.select(slides[findSlideIndex(slide)]);\r\n      if (slides.length === 1) {\r\n        $scope.play();\r\n      }\r\n    }\r\n  };\r\n\r\n  self.getCurrentIndex = function() {\r\n    for (var i = 0; i < slides.length; i++) {\r\n      if (slides[i].slide.index === currentIndex) {\r\n        return i;\r\n      }\r\n    }\r\n  };\r\n\r\n  self.next = $scope.next = function() {\r\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\r\n\r\n    if (newIndex === 0 && $scope.noWrap()) {\r\n      $scope.pause();\r\n      return;\r\n    }\r\n\r\n    return self.select(slides[newIndex], 'next');\r\n  };\r\n\r\n  self.prev = $scope.prev = function() {\r\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\r\n\r\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\r\n      $scope.pause();\r\n      return;\r\n    }\r\n\r\n    return self.select(slides[newIndex], 'prev');\r\n  };\r\n\r\n  self.removeSlide = function(slide) {\r\n    var index = findSlideIndex(slide);\r\n\r\n    var bufferedIndex = bufferedTransitions.indexOf(slides[index]);\r\n    if (bufferedIndex !== -1) {\r\n      bufferedTransitions.splice(bufferedIndex, 1);\r\n    }\r\n\r\n    //get the index of the slide inside the carousel\r\n    slides.splice(index, 1);\r\n    if (slides.length > 0 && currentIndex === index) {\r\n      if (index >= slides.length) {\r\n        currentIndex = slides.length - 1;\r\n        $scope.active = currentIndex;\r\n        setActive(currentIndex);\r\n        self.select(slides[slides.length - 1]);\r\n      } else {\r\n        currentIndex = index;\r\n        $scope.active = currentIndex;\r\n        setActive(currentIndex);\r\n        self.select(slides[index]);\r\n      }\r\n    } else if (currentIndex > index) {\r\n      currentIndex--;\r\n      $scope.active = currentIndex;\r\n    }\r\n\r\n    //clean the active value when no more slide\r\n    if (slides.length === 0) {\r\n      currentIndex = null;\r\n      $scope.active = null;\r\n      clearBufferedTransitions();\r\n    }\r\n  };\r\n\r\n  /* direction: \"prev\" or \"next\" */\r\n  self.select = $scope.select = function(nextSlide, direction) {\r\n    var nextIndex = findSlideIndex(nextSlide.slide);\r\n    //Decide direction if it's not given\r\n    if (direction === undefined) {\r\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\r\n    }\r\n    //Prevent this user-triggered transition from occurring if there is already one in progress\r\n    if (nextSlide.slide.index !== currentIndex &&\r\n      !$scope.$currentTransition) {\r\n      goNext(nextSlide.slide, nextIndex, direction);\r\n    } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {\r\n      bufferedTransitions.push(slides[nextIndex]);\r\n    }\r\n  };\r\n\r\n  /* Allow outside people to call indexOf on slides array */\r\n  $scope.indexOfSlide = function(slide) {\r\n    return +slide.slide.index;\r\n  };\r\n\r\n  $scope.isActive = function(slide) {\r\n    return $scope.active === slide.slide.index;\r\n  };\r\n\r\n  $scope.isPrevDisabled = function() {\r\n    return $scope.active === 0 && $scope.noWrap();\r\n  };\r\n\r\n  $scope.isNextDisabled = function() {\r\n    return $scope.active === slides.length - 1 && $scope.noWrap();\r\n  };\r\n\r\n  $scope.pause = function() {\r\n    if (!$scope.noPause) {\r\n      isPlaying = false;\r\n      resetTimer();\r\n    }\r\n  };\r\n\r\n  $scope.play = function() {\r\n    if (!isPlaying) {\r\n      isPlaying = true;\r\n      restartTimer();\r\n    }\r\n  };\r\n\r\n  $scope.$on('$destroy', function() {\r\n    destroyed = true;\r\n    resetTimer();\r\n  });\r\n\r\n  $scope.$watch('noTransition', function(noTransition) {\r\n    $animate.enabled($element, !noTransition);\r\n  });\r\n\r\n  $scope.$watch('interval', restartTimer);\r\n\r\n  $scope.$watchCollection('slides', resetTransition);\r\n\r\n  $scope.$watch('active', function(index) {\r\n    if (angular.isNumber(index) && currentIndex !== index) {\r\n      for (var i = 0; i < slides.length; i++) {\r\n        if (slides[i].slide.index === index) {\r\n          index = i;\r\n          break;\r\n        }\r\n      }\r\n\r\n      var slide = slides[index];\r\n      if (slide) {\r\n        setActive(index);\r\n        self.select(slides[index]);\r\n        currentIndex = index;\r\n      }\r\n    }\r\n  });\r\n\r\n  function clearBufferedTransitions() {\r\n    while (bufferedTransitions.length) {\r\n      bufferedTransitions.shift();\r\n    }\r\n  }\r\n\r\n  function getSlideByIndex(index) {\r\n    for (var i = 0, l = slides.length; i < l; ++i) {\r\n      if (slides[i].index === index) {\r\n        return slides[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  function setActive(index) {\r\n    for (var i = 0; i < slides.length; i++) {\r\n      slides[i].slide.active = i === index;\r\n    }\r\n  }\r\n\r\n  function goNext(slide, index, direction) {\r\n    if (destroyed) {\r\n      return;\r\n    }\r\n\r\n    angular.extend(slide, {direction: direction});\r\n    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\r\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\r\n      slides[index].element && self.slides.length > 1) {\r\n      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\r\n      var currentIdx = self.getCurrentIndex();\r\n\r\n      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\r\n        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\r\n      }\r\n\r\n      $scope.$currentTransition = true;\r\n      $animate.on('addClass', slides[index].element, function(element, phase) {\r\n        if (phase === 'close') {\r\n          $scope.$currentTransition = null;\r\n          $animate.off('addClass', element);\r\n          if (bufferedTransitions.length) {\r\n            var nextSlide = bufferedTransitions.pop().slide;\r\n            var nextIndex = nextSlide.index;\r\n            var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\r\n            clearBufferedTransitions();\r\n\r\n            goNext(nextSlide, nextIndex, nextDirection);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    $scope.active = slide.index;\r\n    currentIndex = slide.index;\r\n    setActive(index);\r\n\r\n    //every time you change slides, reset the timer\r\n    restartTimer();\r\n  }\r\n\r\n  function findSlideIndex(slide) {\r\n    for (var i = 0; i < slides.length; i++) {\r\n      if (slides[i].slide === slide) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function resetTimer() {\r\n    if (currentInterval) {\r\n      $interval.cancel(currentInterval);\r\n      currentInterval = null;\r\n    }\r\n  }\r\n\r\n  function resetTransition(slides) {\r\n    if (!slides.length) {\r\n      $scope.$currentTransition = null;\r\n      clearBufferedTransitions();\r\n    }\r\n  }\r\n\r\n  function restartTimer() {\r\n    resetTimer();\r\n    var interval = +$scope.interval;\r\n    if (!isNaN(interval) && interval > 0) {\r\n      currentInterval = $interval(timerFn, interval);\r\n    }\r\n  }\r\n\r\n  function timerFn() {\r\n    var interval = +$scope.interval;\r\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\r\n      $scope.next();\r\n    } else {\r\n      $scope.pause();\r\n    }\r\n  }\r\n}])\r\n\r\n.directive('uibCarousel', function() {\r\n  return {\r\n    transclude: true,\r\n    replace: true,\r\n    controller: 'UibCarouselController',\r\n    controllerAs: 'carousel',\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\r\n    },\r\n    scope: {\r\n      active: '=',\r\n      interval: '=',\r\n      noTransition: '=',\r\n      noPause: '=',\r\n      noWrap: '&'\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibSlide', function() {\r\n  return {\r\n    require: '^uibCarousel',\r\n    transclude: true,\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\r\n    },\r\n    scope: {\r\n      actual: '=?',\r\n      index: '=?'\r\n    },\r\n    link: function (scope, element, attrs, carouselCtrl) {\r\n      carouselCtrl.addSlide(scope, element);\r\n      //when the scope is destroyed then remove the slide from the current slides array\r\n      scope.$on('$destroy', function() {\r\n        carouselCtrl.removeSlide(scope);\r\n      });\r\n    }\r\n  };\r\n})\r\n\r\n.animation('.item', ['$animateCss',\r\nfunction($animateCss) {\r\n  var SLIDE_DIRECTION = 'uib-slideDirection';\r\n\r\n  function removeClass(element, className, callback) {\r\n    element.removeClass(className);\r\n    if (callback) {\r\n      callback();\r\n    }\r\n  }\r\n\r\n  return {\r\n    beforeAddClass: function(element, className, done) {\r\n      if (className === 'active') {\r\n        var stopped = false;\r\n        var direction = element.data(SLIDE_DIRECTION);\r\n        var directionClass = direction === 'next' ? 'left' : 'right';\r\n        var removeClassFn = removeClass.bind(this, element,\r\n          directionClass + ' ' + direction, done);\r\n        element.addClass(direction);\r\n\r\n        $animateCss(element, {addClass: directionClass})\r\n          .start()\r\n          .done(removeClassFn);\r\n\r\n        return function() {\r\n          stopped = true;\r\n        };\r\n      }\r\n      done();\r\n    },\r\n    beforeRemoveClass: function (element, className, done) {\r\n      if (className === 'active') {\r\n        var stopped = false;\r\n        var direction = element.data(SLIDE_DIRECTION);\r\n        var directionClass = direction === 'next' ? 'left' : 'right';\r\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\r\n\r\n        $animateCss(element, {addClass: directionClass})\r\n          .start()\r\n          .done(removeClassFn);\r\n\r\n        return function() {\r\n          stopped = true;\r\n        };\r\n      }\r\n      done();\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.dateparser', [])\r\n\r\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', function($log, $locale, dateFilter, orderByFilter) {\r\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\r\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\r\n\r\n  var localeId;\r\n  var formatCodeToRegex;\r\n\r\n  this.init = function() {\r\n    localeId = $locale.id;\r\n\r\n    this.parsers = {};\r\n    this.formatters = {};\r\n\r\n    formatCodeToRegex = [\r\n      {\r\n        key: 'yyyy',\r\n        regex: '\\\\d{4}',\r\n        apply: function(value) { this.year = +value; },\r\n        formatter: function(date) {\r\n          var _date = new Date();\r\n          _date.setFullYear(Math.abs(date.getFullYear()));\r\n          return dateFilter(_date, 'yyyy');\r\n        }\r\n      },\r\n      {\r\n        key: 'yy',\r\n        regex: '\\\\d{2}',\r\n        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },\r\n        formatter: function(date) {\r\n          var _date = new Date();\r\n          _date.setFullYear(Math.abs(date.getFullYear()));\r\n          return dateFilter(_date, 'yy');\r\n        }\r\n      },\r\n      {\r\n        key: 'y',\r\n        regex: '\\\\d{1,4}',\r\n        apply: function(value) { this.year = +value; },\r\n        formatter: function(date) {\r\n          var _date = new Date();\r\n          _date.setFullYear(Math.abs(date.getFullYear()));\r\n          return dateFilter(_date, 'y');\r\n        }\r\n      },\r\n      {\r\n        key: 'M!',\r\n        regex: '0?[1-9]|1[0-2]',\r\n        apply: function(value) { this.month = value - 1; },\r\n        formatter: function(date) {\r\n          var value = date.getMonth();\r\n          if (/^[0-9]$/.test(value)) {\r\n            return dateFilter(date, 'MM');\r\n          }\r\n\r\n          return dateFilter(date, 'M');\r\n        }\r\n      },\r\n      {\r\n        key: 'MMMM',\r\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\r\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\r\n      },\r\n      {\r\n        key: 'MMM',\r\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\r\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\r\n      },\r\n      {\r\n        key: 'MM',\r\n        regex: '0[1-9]|1[0-2]',\r\n        apply: function(value) { this.month = value - 1; },\r\n        formatter: function(date) { return dateFilter(date, 'MM'); }\r\n      },\r\n      {\r\n        key: 'M',\r\n        regex: '[1-9]|1[0-2]',\r\n        apply: function(value) { this.month = value - 1; },\r\n        formatter: function(date) { return dateFilter(date, 'M'); }\r\n      },\r\n      {\r\n        key: 'd!',\r\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\r\n        apply: function(value) { this.date = +value; },\r\n        formatter: function(date) {\r\n          var value = date.getDate();\r\n          if (/^[1-9]$/.test(value)) {\r\n            return dateFilter(date, 'dd');\r\n          }\r\n\r\n          return dateFilter(date, 'd');\r\n        }\r\n      },\r\n      {\r\n        key: 'dd',\r\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\r\n        apply: function(value) { this.date = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'dd'); }\r\n      },\r\n      {\r\n        key: 'd',\r\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\r\n        apply: function(value) { this.date = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'd'); }\r\n      },\r\n      {\r\n        key: 'EEEE',\r\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\r\n      },\r\n      {\r\n        key: 'EEE',\r\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\r\n      },\r\n      {\r\n        key: 'HH',\r\n        regex: '(?:0|1)[0-9]|2[0-3]',\r\n        apply: function(value) { this.hours = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'HH'); }\r\n      },\r\n      {\r\n        key: 'hh',\r\n        regex: '0[0-9]|1[0-2]',\r\n        apply: function(value) { this.hours = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'hh'); }\r\n      },\r\n      {\r\n        key: 'H',\r\n        regex: '1?[0-9]|2[0-3]',\r\n        apply: function(value) { this.hours = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'H'); }\r\n      },\r\n      {\r\n        key: 'h',\r\n        regex: '[0-9]|1[0-2]',\r\n        apply: function(value) { this.hours = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'h'); }\r\n      },\r\n      {\r\n        key: 'mm',\r\n        regex: '[0-5][0-9]',\r\n        apply: function(value) { this.minutes = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'mm'); }\r\n      },\r\n      {\r\n        key: 'm',\r\n        regex: '[0-9]|[1-5][0-9]',\r\n        apply: function(value) { this.minutes = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'm'); }\r\n      },\r\n      {\r\n        key: 'sss',\r\n        regex: '[0-9][0-9][0-9]',\r\n        apply: function(value) { this.milliseconds = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'sss'); }\r\n      },\r\n      {\r\n        key: 'ss',\r\n        regex: '[0-5][0-9]',\r\n        apply: function(value) { this.seconds = +value; },\r\n        formatter: function(date) { return dateFilter(date, 'ss'); }\r\n      },\r\n      {\r\n        key: 's',\r\n        regex: '[0-9]|[1-5][0-9]',\r\n        apply: function(value) { this.seconds = +value; },\r\n        formatter: function(date) { return dateFilter(date, 's'); }\r\n      },\r\n      {\r\n        key: 'a',\r\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\r\n        apply: function(value) {\r\n          if (this.hours === 12) {\r\n            this.hours = 0;\r\n          }\r\n\r\n          if (value === 'PM') {\r\n            this.hours += 12;\r\n          }\r\n        },\r\n        formatter: function(date) { return dateFilter(date, 'a'); }\r\n      },\r\n      {\r\n        key: 'Z',\r\n        regex: '[+-]\\\\d{4}',\r\n        apply: function(value) {\r\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\r\n            sign = matches[1],\r\n            hours = matches[2],\r\n            minutes = matches[3];\r\n          this.hours += toInt(sign + hours);\r\n          this.minutes += toInt(sign + minutes);\r\n        },\r\n        formatter: function(date) {\r\n          return dateFilter(date, 'Z');\r\n        }\r\n      },\r\n      {\r\n        key: 'ww',\r\n        regex: '[0-4][0-9]|5[0-3]',\r\n        formatter: function(date) { return dateFilter(date, 'ww'); }\r\n      },\r\n      {\r\n        key: 'w',\r\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\r\n        formatter: function(date) { return dateFilter(date, 'w'); }\r\n      },\r\n      {\r\n        key: 'GGGG',\r\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\r\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\r\n      },\r\n      {\r\n        key: 'GGG',\r\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\r\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\r\n      },\r\n      {\r\n        key: 'GG',\r\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\r\n        formatter: function(date) { return dateFilter(date, 'GG'); }\r\n      },\r\n      {\r\n        key: 'G',\r\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\r\n        formatter: function(date) { return dateFilter(date, 'G'); }\r\n      }\r\n    ];\r\n  };\r\n\r\n  this.init();\r\n\r\n  function createParser(format, func) {\r\n    var map = [], regex = format.split('');\r\n\r\n    // check for literal values\r\n    var quoteIndex = format.indexOf('\\'');\r\n    if (quoteIndex > -1) {\r\n      var inLiteral = false;\r\n      format = format.split('');\r\n      for (var i = quoteIndex; i < format.length; i++) {\r\n        if (inLiteral) {\r\n          if (format[i] === '\\'') {\r\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\r\n              format[i+1] = '$';\r\n              regex[i+1] = '';\r\n            } else { // end of literal\r\n              regex[i] = '';\r\n              inLiteral = false;\r\n            }\r\n          }\r\n          format[i] = '$';\r\n        } else {\r\n          if (format[i] === '\\'') { // start of literal\r\n            format[i] = '$';\r\n            regex[i] = '';\r\n            inLiteral = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      format = format.join('');\r\n    }\r\n\r\n    angular.forEach(formatCodeToRegex, function(data) {\r\n      var index = format.indexOf(data.key);\r\n\r\n      if (index > -1) {\r\n        format = format.split('');\r\n\r\n        regex[index] = '(' + data.regex + ')';\r\n        format[index] = '$'; // Custom symbol to define consumed part of format\r\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\r\n          regex[i] = '';\r\n          format[i] = '$';\r\n        }\r\n        format = format.join('');\r\n\r\n        map.push({\r\n          index: index,\r\n          key: data.key,\r\n          apply: data[func],\r\n          matcher: data.regex\r\n        });\r\n      }\r\n    });\r\n\r\n    return {\r\n      regex: new RegExp('^' + regex.join('') + '$'),\r\n      map: orderByFilter(map, 'index')\r\n    };\r\n  }\r\n\r\n  this.filter = function(date, format) {\r\n    if (!angular.isDate(date) || isNaN(date) || !format) {\r\n      return '';\r\n    }\r\n\r\n    format = $locale.DATETIME_FORMATS[format] || format;\r\n\r\n    if ($locale.id !== localeId) {\r\n      this.init();\r\n    }\r\n\r\n    if (!this.formatters[format]) {\r\n      this.formatters[format] = createParser(format, 'formatter');\r\n    }\r\n\r\n    var parser = this.formatters[format],\r\n      map = parser.map;\r\n\r\n    var _format = format;\r\n\r\n    return map.reduce(function(str, mapper, i) {\r\n      var match = _format.match(new RegExp('(.*)' + mapper.key));\r\n      if (match && angular.isString(match[1])) {\r\n        str += match[1];\r\n        _format = _format.replace(match[1] + mapper.key, '');\r\n      }\r\n\r\n      var endStr = i === map.length - 1 ? _format : '';\r\n\r\n      if (mapper.apply) {\r\n        return str + mapper.apply.call(null, date) + endStr;\r\n      }\r\n\r\n      return str + endStr;\r\n    }, '');\r\n  };\r\n\r\n  this.parse = function(input, format, baseDate) {\r\n    if (!angular.isString(input) || !format) {\r\n      return input;\r\n    }\r\n\r\n    format = $locale.DATETIME_FORMATS[format] || format;\r\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\r\n\r\n    if ($locale.id !== localeId) {\r\n      this.init();\r\n    }\r\n\r\n    if (!this.parsers[format]) {\r\n      this.parsers[format] = createParser(format, 'apply');\r\n    }\r\n\r\n    var parser = this.parsers[format],\r\n        regex = parser.regex,\r\n        map = parser.map,\r\n        results = input.match(regex),\r\n        tzOffset = false;\r\n    if (results && results.length) {\r\n      var fields, dt;\r\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\r\n        fields = {\r\n          year: baseDate.getFullYear(),\r\n          month: baseDate.getMonth(),\r\n          date: baseDate.getDate(),\r\n          hours: baseDate.getHours(),\r\n          minutes: baseDate.getMinutes(),\r\n          seconds: baseDate.getSeconds(),\r\n          milliseconds: baseDate.getMilliseconds()\r\n        };\r\n      } else {\r\n        if (baseDate) {\r\n          $log.warn('dateparser:', 'baseDate is not a valid date');\r\n        }\r\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\r\n      }\r\n\r\n      for (var i = 1, n = results.length; i < n; i++) {\r\n        var mapper = map[i - 1];\r\n        if (mapper.matcher === 'Z') {\r\n          tzOffset = true;\r\n        }\r\n\r\n        if (mapper.apply) {\r\n          mapper.apply.call(fields, results[i]);\r\n        }\r\n      }\r\n\r\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\r\n        Date.prototype.setFullYear;\r\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\r\n        Date.prototype.setHours;\r\n\r\n      if (isValid(fields.year, fields.month, fields.date)) {\r\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\r\n          dt = new Date(baseDate);\r\n          datesetter.call(dt, fields.year, fields.month, fields.date);\r\n          timesetter.call(dt, fields.hours, fields.minutes,\r\n            fields.seconds, fields.milliseconds);\r\n        } else {\r\n          dt = new Date(0);\r\n          datesetter.call(dt, fields.year, fields.month, fields.date);\r\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\r\n            fields.seconds || 0, fields.milliseconds || 0);\r\n        }\r\n      }\r\n\r\n      return dt;\r\n    }\r\n  };\r\n\r\n  // Check if date is valid for specific month (and year for February).\r\n  // Month: 0 = Jan, 1 = Feb, etc\r\n  function isValid(year, month, date) {\r\n    if (date < 1) {\r\n      return false;\r\n    }\r\n\r\n    if (month === 1 && date > 28) {\r\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\r\n    }\r\n\r\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\r\n      return date < 31;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function toInt(str) {\r\n    return parseInt(str, 10);\r\n  }\r\n\r\n  this.toTimezone = toTimezone;\r\n  this.fromTimezone = fromTimezone;\r\n  this.timezoneToOffset = timezoneToOffset;\r\n  this.addDateMinutes = addDateMinutes;\r\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\r\n\r\n  function toTimezone(date, timezone) {\r\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\r\n  }\r\n\r\n  function fromTimezone(date, timezone) {\r\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\r\n  }\r\n\r\n  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207\r\n  function timezoneToOffset(timezone, fallback) {\r\n    timezone = timezone.replace(/:/g, '');\r\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\r\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\r\n  }\r\n\r\n  function addDateMinutes(date, minutes) {\r\n    date = new Date(date.getTime());\r\n    date.setMinutes(date.getMinutes() + minutes);\r\n    return date;\r\n  }\r\n\r\n  function convertTimezoneToLocal(date, timezone, reverse) {\r\n    reverse = reverse ? -1 : 1;\r\n    var dateTimezoneOffset = date.getTimezoneOffset();\r\n    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\r\n    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\r\n  }\r\n}]);\r\n\r\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\r\n// at most one element.\r\nangular.module('ui.bootstrap.isClass', [])\r\n.directive('uibIsClass', [\r\n         '$animate',\r\nfunction ($animate) {\r\n  //                    11111111          22222222\r\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\r\n  //                    11111111           22222222\r\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\r\n\r\n  var dataPerTracked = {};\r\n\r\n  return {\r\n    restrict: 'A',\r\n    compile: function(tElement, tAttrs) {\r\n      var linkedScopes = [];\r\n      var instances = [];\r\n      var expToData = {};\r\n      var lastActivated = null;\r\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\r\n      var onExp = onExpMatches[2];\r\n      var expsStr = onExpMatches[1];\r\n      var exps = expsStr.split(',');\r\n\r\n      return linkFn;\r\n\r\n      function linkFn(scope, element, attrs) {\r\n        linkedScopes.push(scope);\r\n        instances.push({\r\n          scope: scope,\r\n          element: element\r\n        });\r\n\r\n        exps.forEach(function(exp, k) {\r\n          addForExp(exp, scope);\r\n        });\r\n\r\n        scope.$on('$destroy', removeScope);\r\n      }\r\n\r\n      function addForExp(exp, scope) {\r\n        var matches = exp.match(IS_REGEXP);\r\n        var clazz = scope.$eval(matches[1]);\r\n        var compareWithExp = matches[2];\r\n        var data = expToData[exp];\r\n        if (!data) {\r\n          var watchFn = function(compareWithVal) {\r\n            var newActivated = null;\r\n            instances.some(function(instance) {\r\n              var thisVal = instance.scope.$eval(onExp);\r\n              if (thisVal === compareWithVal) {\r\n                newActivated = instance;\r\n                return true;\r\n              }\r\n            });\r\n            if (data.lastActivated !== newActivated) {\r\n              if (data.lastActivated) {\r\n                $animate.removeClass(data.lastActivated.element, clazz);\r\n              }\r\n              if (newActivated) {\r\n                $animate.addClass(newActivated.element, clazz);\r\n              }\r\n              data.lastActivated = newActivated;\r\n            }\r\n          };\r\n          expToData[exp] = data = {\r\n            lastActivated: null,\r\n            scope: scope,\r\n            watchFn: watchFn,\r\n            compareWithExp: compareWithExp,\r\n            watcher: scope.$watch(compareWithExp, watchFn)\r\n          };\r\n        }\r\n        data.watchFn(scope.$eval(compareWithExp));\r\n      }\r\n\r\n      function removeScope(e) {\r\n        var removedScope = e.targetScope;\r\n        var index = linkedScopes.indexOf(removedScope);\r\n        linkedScopes.splice(index, 1);\r\n        instances.splice(index, 1);\r\n        if (linkedScopes.length) {\r\n          var newWatchScope = linkedScopes[0];\r\n          angular.forEach(expToData, function(data) {\r\n            if (data.scope === removedScope) {\r\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\r\n              data.scope = newWatchScope;\r\n            }\r\n          });\r\n        } else {\r\n          expToData = {};\r\n        }\r\n      }\r\n    }\r\n  };\r\n}]);\r\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])\r\n\r\n.value('$datepickerSuppressError', false)\r\n\r\n.value('$datepickerLiteralWarning', true)\r\n\r\n.constant('uibDatepickerConfig', {\r\n  datepickerMode: 'day',\r\n  formatDay: 'dd',\r\n  formatMonth: 'MMMM',\r\n  formatYear: 'yyyy',\r\n  formatDayHeader: 'EEE',\r\n  formatDayTitle: 'MMMM yyyy',\r\n  formatMonthTitle: 'yyyy',\r\n  maxDate: null,\r\n  maxMode: 'year',\r\n  minDate: null,\r\n  minMode: 'day',\r\n  ngModelOptions: {},\r\n  shortcutPropagation: false,\r\n  showWeeks: true,\r\n  yearColumns: 5,\r\n  yearRows: 4\r\n})\r\n\r\n.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',\r\n  function($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {\r\n  var self = this,\r\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\r\n      ngModelOptions = {},\r\n      watchListeners = [],\r\n      optionsUsed = !!$attrs.datepickerOptions;\r\n\r\n  if (!$scope.datepickerOptions) {\r\n    $scope.datepickerOptions = {};\r\n  }\r\n\r\n  // Modes chain\r\n  this.modes = ['day', 'month', 'year'];\r\n\r\n  [\r\n    'customClass',\r\n    'dateDisabled',\r\n    'datepickerMode',\r\n    'formatDay',\r\n    'formatDayHeader',\r\n    'formatDayTitle',\r\n    'formatMonth',\r\n    'formatMonthTitle',\r\n    'formatYear',\r\n    'maxDate',\r\n    'maxMode',\r\n    'minDate',\r\n    'minMode',\r\n    'showWeeks',\r\n    'shortcutPropagation',\r\n    'startingDay',\r\n    'yearColumns',\r\n    'yearRows'\r\n  ].forEach(function(key) {\r\n    switch (key) {\r\n      case 'customClass':\r\n      case 'dateDisabled':\r\n        $scope[key] = $scope.datepickerOptions[key] || angular.noop;\r\n        break;\r\n      case 'datepickerMode':\r\n        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\r\n          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\r\n        break;\r\n      case 'formatDay':\r\n      case 'formatDayHeader':\r\n      case 'formatDayTitle':\r\n      case 'formatMonth':\r\n      case 'formatMonthTitle':\r\n      case 'formatYear':\r\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\r\n          $interpolate($scope.datepickerOptions[key])($scope.$parent) :\r\n          datepickerConfig[key];\r\n        break;\r\n      case 'showWeeks':\r\n      case 'shortcutPropagation':\r\n      case 'yearColumns':\r\n      case 'yearRows':\r\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\r\n          $scope.datepickerOptions[key] : datepickerConfig[key];\r\n        break;\r\n      case 'startingDay':\r\n        if (angular.isDefined($scope.datepickerOptions.startingDay)) {\r\n          self.startingDay = $scope.datepickerOptions.startingDay;\r\n        } else if (angular.isNumber(datepickerConfig.startingDay)) {\r\n          self.startingDay = datepickerConfig.startingDay;\r\n        } else {\r\n          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\r\n        }\r\n\r\n        break;\r\n      case 'maxDate':\r\n      case 'minDate':\r\n        $scope.$watch('datepickerOptions.' + key, function(value) {\r\n          if (value) {\r\n            if (angular.isDate(value)) {\r\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);\r\n            } else {\r\n              if ($datepickerLiteralWarning) {\r\n                $log.warn('Literal date support has been deprecated, please switch to date object usage');\r\n              }\r\n\r\n              self[key] = new Date(dateFilter(value, 'medium'));\r\n            }\r\n          } else {\r\n            self[key] = datepickerConfig[key] ?\r\n              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) :\r\n              null;\r\n          }\r\n\r\n          self.refreshView();\r\n        });\r\n\r\n        break;\r\n      case 'maxMode':\r\n      case 'minMode':\r\n        if ($scope.datepickerOptions[key]) {\r\n          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\r\n            self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];\r\n            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\r\n              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\r\n              $scope.datepickerMode = self[key];\r\n              $scope.datepickerOptions.datepickerMode = self[key];\r\n            }\r\n          });\r\n        } else {\r\n          self[key] = $scope[key] = datepickerConfig[key] || null;\r\n        }\r\n\r\n        break;\r\n    }\r\n  });\r\n\r\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\r\n\r\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\r\n  if (angular.isDefined($attrs.ngDisabled)) {\r\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\r\n      $scope.disabled = disabled;\r\n      self.refreshView();\r\n    }));\r\n  }\r\n\r\n  $scope.isActive = function(dateObject) {\r\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\r\n      $scope.activeDateId = dateObject.uid;\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  this.init = function(ngModelCtrl_) {\r\n    ngModelCtrl = ngModelCtrl_;\r\n    ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;\r\n    if ($scope.datepickerOptions.initDate) {\r\n      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();\r\n      $scope.$watch('datepickerOptions.initDate', function(initDate) {\r\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\r\n          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);\r\n          self.refreshView();\r\n        }\r\n      });\r\n    } else {\r\n      self.activeDate = new Date();\r\n    }\r\n\r\n    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();\r\n    this.activeDate = !isNaN(date) ?\r\n      dateParser.fromTimezone(date, ngModelOptions.timezone) :\r\n      dateParser.fromTimezone(new Date(), ngModelOptions.timezone);\r\n\r\n    ngModelCtrl.$render = function() {\r\n      self.render();\r\n    };\r\n  };\r\n\r\n  this.render = function() {\r\n    if (ngModelCtrl.$viewValue) {\r\n      var date = new Date(ngModelCtrl.$viewValue),\r\n          isValid = !isNaN(date);\r\n\r\n      if (isValid) {\r\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);\r\n      } else if (!$datepickerSuppressError) {\r\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\r\n      }\r\n    }\r\n    this.refreshView();\r\n  };\r\n\r\n  this.refreshView = function() {\r\n    if (this.element) {\r\n      $scope.selectedDt = null;\r\n      this._refreshView();\r\n      if ($scope.activeDt) {\r\n        $scope.activeDateId = $scope.activeDt.uid;\r\n      }\r\n\r\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\r\n      date = dateParser.fromTimezone(date, ngModelOptions.timezone);\r\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\r\n        this.element && !this.isDisabled(date));\r\n    }\r\n  };\r\n\r\n  this.createDateObject = function(date, format) {\r\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\r\n    model = dateParser.fromTimezone(model, ngModelOptions.timezone);\r\n    var today = new Date();\r\n    today = dateParser.fromTimezone(today, ngModelOptions.timezone);\r\n    var time = this.compare(date, today);\r\n    var dt = {\r\n      date: date,\r\n      label: dateParser.filter(date, format),\r\n      selected: model && this.compare(date, model) === 0,\r\n      disabled: this.isDisabled(date),\r\n      past: time < 0,\r\n      current: time === 0,\r\n      future: time > 0,\r\n      customClass: this.customClass(date) || null\r\n    };\r\n\r\n    if (model && this.compare(date, model) === 0) {\r\n      $scope.selectedDt = dt;\r\n    }\r\n\r\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\r\n      $scope.activeDt = dt;\r\n    }\r\n\r\n    return dt;\r\n  };\r\n\r\n  this.isDisabled = function(date) {\r\n    return $scope.disabled ||\r\n      this.minDate && this.compare(date, this.minDate) < 0 ||\r\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\r\n      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\r\n  };\r\n\r\n  this.customClass = function(date) {\r\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\r\n  };\r\n\r\n  // Split array into smaller arrays\r\n  this.split = function(arr, size) {\r\n    var arrays = [];\r\n    while (arr.length > 0) {\r\n      arrays.push(arr.splice(0, size));\r\n    }\r\n    return arrays;\r\n  };\r\n\r\n  $scope.select = function(date) {\r\n    if ($scope.datepickerMode === self.minMode) {\r\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);\r\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\r\n      dt = dateParser.toTimezone(dt, ngModelOptions.timezone);\r\n      ngModelCtrl.$setViewValue(dt);\r\n      ngModelCtrl.$render();\r\n    } else {\r\n      self.activeDate = date;\r\n      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\r\n\r\n      $scope.$emit('uib:datepicker.mode');\r\n    }\r\n\r\n    $scope.$broadcast('uib:datepicker.focus');\r\n  };\r\n\r\n  $scope.move = function(direction) {\r\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\r\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\r\n    self.activeDate.setFullYear(year, month, 1);\r\n    self.refreshView();\r\n  };\r\n\r\n  $scope.toggleMode = function(direction) {\r\n    direction = direction || 1;\r\n\r\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\r\n      $scope.datepickerMode === self.minMode && direction === -1) {\r\n      return;\r\n    }\r\n\r\n    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\r\n\r\n    $scope.$emit('uib:datepicker.mode');\r\n  };\r\n\r\n  // Key event mapper\r\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\r\n\r\n  var focusElement = function() {\r\n    self.element[0].focus();\r\n  };\r\n\r\n  // Listen for focus requests from popup directive\r\n  $scope.$on('uib:datepicker.focus', focusElement);\r\n\r\n  $scope.keydown = function(evt) {\r\n    var key = $scope.keys[evt.which];\r\n\r\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\r\n      return;\r\n    }\r\n\r\n    evt.preventDefault();\r\n    if (!self.shortcutPropagation) {\r\n      evt.stopPropagation();\r\n    }\r\n\r\n    if (key === 'enter' || key === 'space') {\r\n      if (self.isDisabled(self.activeDate)) {\r\n        return; // do nothing\r\n      }\r\n      $scope.select(self.activeDate);\r\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\r\n      $scope.toggleMode(key === 'up' ? 1 : -1);\r\n    } else {\r\n      self.handleKeyDown(key, evt);\r\n      self.refreshView();\r\n    }\r\n  };\r\n\r\n  $scope.$on('$destroy', function() {\r\n    //Clear all watch listeners on destroy\r\n    while (watchListeners.length) {\r\n      watchListeners.shift()();\r\n    }\r\n  });\r\n\r\n  function setMode(mode) {\r\n    $scope.datepickerMode = mode;\r\n    $scope.datepickerOptions.datepickerMode = mode;\r\n  }\r\n}])\r\n\r\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\r\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n  this.step = { months: 1 };\r\n  this.element = $element;\r\n  function getDaysInMonth(year, month) {\r\n    return month === 1 && year % 4 === 0 &&\r\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\r\n  }\r\n\r\n  this.init = function(ctrl) {\r\n    angular.extend(ctrl, this);\r\n    scope.showWeeks = ctrl.showWeeks;\r\n    ctrl.refreshView();\r\n  };\r\n\r\n  this.getDates = function(startDate, n) {\r\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\r\n    while (i < n) {\r\n      date = new Date(current);\r\n      dates[i++] = date;\r\n      current.setDate(current.getDate() + 1);\r\n    }\r\n    return dates;\r\n  };\r\n\r\n  this._refreshView = function() {\r\n    var year = this.activeDate.getFullYear(),\r\n      month = this.activeDate.getMonth(),\r\n      firstDayOfMonth = new Date(this.activeDate);\r\n\r\n    firstDayOfMonth.setFullYear(year, month, 1);\r\n\r\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\r\n      numDisplayedFromPreviousMonth = difference > 0 ?\r\n        7 - difference : - difference,\r\n      firstDate = new Date(firstDayOfMonth);\r\n\r\n    if (numDisplayedFromPreviousMonth > 0) {\r\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\r\n    }\r\n\r\n    // 42 is the number of days on a six-week calendar\r\n    var days = this.getDates(firstDate, 42);\r\n    for (var i = 0; i < 42; i ++) {\r\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\r\n        secondary: days[i].getMonth() !== month,\r\n        uid: scope.uniqueId + '-' + i\r\n      });\r\n    }\r\n\r\n    scope.labels = new Array(7);\r\n    for (var j = 0; j < 7; j++) {\r\n      scope.labels[j] = {\r\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\r\n        full: dateFilter(days[j].date, 'EEEE')\r\n      };\r\n    }\r\n\r\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\r\n    scope.rows = this.split(days, 7);\r\n\r\n    if (scope.showWeeks) {\r\n      scope.weekNumbers = [];\r\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\r\n          numWeeks = scope.rows.length;\r\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\r\n        scope.weekNumbers.push(\r\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\r\n      }\r\n    }\r\n  };\r\n\r\n  this.compare = function(date1, date2) {\r\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\r\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\r\n    _date1.setFullYear(date1.getFullYear());\r\n    _date2.setFullYear(date2.getFullYear());\r\n    return _date1 - _date2;\r\n  };\r\n\r\n  function getISO8601WeekNumber(date) {\r\n    var checkDate = new Date(date);\r\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\r\n    var time = checkDate.getTime();\r\n    checkDate.setMonth(0); // Compare with Jan 1\r\n    checkDate.setDate(1);\r\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\r\n  }\r\n\r\n  this.handleKeyDown = function(key, evt) {\r\n    var date = this.activeDate.getDate();\r\n\r\n    if (key === 'left') {\r\n      date = date - 1;\r\n    } else if (key === 'up') {\r\n      date = date - 7;\r\n    } else if (key === 'right') {\r\n      date = date + 1;\r\n    } else if (key === 'down') {\r\n      date = date + 7;\r\n    } else if (key === 'pageup' || key === 'pagedown') {\r\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\r\n      this.activeDate.setMonth(month, 1);\r\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\r\n    } else if (key === 'home') {\r\n      date = 1;\r\n    } else if (key === 'end') {\r\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\r\n    }\r\n    this.activeDate.setDate(date);\r\n  };\r\n}])\r\n\r\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\r\n  this.step = { years: 1 };\r\n  this.element = $element;\r\n\r\n  this.init = function(ctrl) {\r\n    angular.extend(ctrl, this);\r\n    ctrl.refreshView();\r\n  };\r\n\r\n  this._refreshView = function() {\r\n    var months = new Array(12),\r\n        year = this.activeDate.getFullYear(),\r\n        date;\r\n\r\n    for (var i = 0; i < 12; i++) {\r\n      date = new Date(this.activeDate);\r\n      date.setFullYear(year, i, 1);\r\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\r\n        uid: scope.uniqueId + '-' + i\r\n      });\r\n    }\r\n\r\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\r\n    scope.rows = this.split(months, 3);\r\n  };\r\n\r\n  this.compare = function(date1, date2) {\r\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\r\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\r\n    _date1.setFullYear(date1.getFullYear());\r\n    _date2.setFullYear(date2.getFullYear());\r\n    return _date1 - _date2;\r\n  };\r\n\r\n  this.handleKeyDown = function(key, evt) {\r\n    var date = this.activeDate.getMonth();\r\n\r\n    if (key === 'left') {\r\n      date = date - 1;\r\n    } else if (key === 'up') {\r\n      date = date - 3;\r\n    } else if (key === 'right') {\r\n      date = date + 1;\r\n    } else if (key === 'down') {\r\n      date = date + 3;\r\n    } else if (key === 'pageup' || key === 'pagedown') {\r\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\r\n      this.activeDate.setFullYear(year);\r\n    } else if (key === 'home') {\r\n      date = 0;\r\n    } else if (key === 'end') {\r\n      date = 11;\r\n    }\r\n    this.activeDate.setMonth(date);\r\n  };\r\n}])\r\n\r\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\r\n  var columns, range;\r\n  this.element = $element;\r\n\r\n  function getStartingYear(year) {\r\n    return parseInt((year - 1) / range, 10) * range + 1;\r\n  }\r\n\r\n  this.yearpickerInit = function() {\r\n    columns = this.yearColumns;\r\n    range = this.yearRows * columns;\r\n    this.step = { years: range };\r\n  };\r\n\r\n  this._refreshView = function() {\r\n    var years = new Array(range), date;\r\n\r\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\r\n      date = new Date(this.activeDate);\r\n      date.setFullYear(start + i, 0, 1);\r\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\r\n        uid: scope.uniqueId + '-' + i\r\n      });\r\n    }\r\n\r\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\r\n    scope.rows = this.split(years, columns);\r\n    scope.columns = columns;\r\n  };\r\n\r\n  this.compare = function(date1, date2) {\r\n    return date1.getFullYear() - date2.getFullYear();\r\n  };\r\n\r\n  this.handleKeyDown = function(key, evt) {\r\n    var date = this.activeDate.getFullYear();\r\n\r\n    if (key === 'left') {\r\n      date = date - 1;\r\n    } else if (key === 'up') {\r\n      date = date - columns;\r\n    } else if (key === 'right') {\r\n      date = date + 1;\r\n    } else if (key === 'down') {\r\n      date = date + columns;\r\n    } else if (key === 'pageup' || key === 'pagedown') {\r\n      date += (key === 'pageup' ? - 1 : 1) * range;\r\n    } else if (key === 'home') {\r\n      date = getStartingYear(this.activeDate.getFullYear());\r\n    } else if (key === 'end') {\r\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\r\n    }\r\n    this.activeDate.setFullYear(date);\r\n  };\r\n}])\r\n\r\n.directive('uibDatepicker', function() {\r\n  return {\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\r\n    },\r\n    scope: {\r\n      datepickerOptions: '=?'\r\n    },\r\n    require: ['uibDatepicker', '^ngModel'],\r\n    controller: 'UibDatepickerController',\r\n    controllerAs: 'datepicker',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n      datepickerCtrl.init(ngModelCtrl);\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibDaypicker', function() {\r\n  return {\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\r\n    },\r\n    require: ['^uibDatepicker', 'uibDaypicker'],\r\n    controller: 'UibDaypickerController',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var datepickerCtrl = ctrls[0],\r\n        daypickerCtrl = ctrls[1];\r\n\r\n      daypickerCtrl.init(datepickerCtrl);\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibMonthpicker', function() {\r\n  return {\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\r\n    },\r\n    require: ['^uibDatepicker', 'uibMonthpicker'],\r\n    controller: 'UibMonthpickerController',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var datepickerCtrl = ctrls[0],\r\n        monthpickerCtrl = ctrls[1];\r\n\r\n      monthpickerCtrl.init(datepickerCtrl);\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibYearpicker', function() {\r\n  return {\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\r\n    },\r\n    require: ['^uibDatepicker', 'uibYearpicker'],\r\n    controller: 'UibYearpickerController',\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var ctrl = ctrls[0];\r\n      angular.extend(ctrl, ctrls[1]);\r\n      ctrl.yearpickerInit();\r\n\r\n      ctrl.refreshView();\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.position', [])\r\n\r\n/**\r\n * A set of utility methods for working with the DOM.\r\n * It is meant to be used where we need to absolute-position elements in\r\n * relation to another element (this is the case for tooltips, popovers,\r\n * typeahead suggestions etc.).\r\n */\r\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\r\n    /**\r\n     * Used by scrollbarWidth() function to cache scrollbar's width.\r\n     * Do not access this variable directly, use scrollbarWidth() instead.\r\n     */\r\n    var SCROLLBAR_WIDTH;\r\n    /**\r\n     * scrollbar on body and html element in IE and Edge overlay\r\n     * content and should be considered 0 width.\r\n     */\r\n    var BODY_SCROLLBAR_WIDTH;\r\n    var OVERFLOW_REGEX = {\r\n      normal: /(auto|scroll)/,\r\n      hidden: /(auto|scroll|hidden)/\r\n    };\r\n    var PLACEMENT_REGEX = {\r\n      auto: /\\s?auto?\\s?/i,\r\n      primary: /^(top|bottom|left|right)$/,\r\n      secondary: /^(top|bottom|left|right|center)$/,\r\n      vertical: /^(top|bottom)$/\r\n    };\r\n    var BODY_REGEX = /(HTML|BODY)/;\r\n\r\n    return {\r\n\r\n      /**\r\n       * Provides a raw DOM element from a jQuery/jQLite element.\r\n       *\r\n       * @param {element} elem - The element to convert.\r\n       *\r\n       * @returns {element} A HTML element.\r\n       */\r\n      getRawNode: function(elem) {\r\n        return elem.nodeName ? elem : elem[0] || elem;\r\n      },\r\n\r\n      /**\r\n       * Provides a parsed number for a style property.  Strips\r\n       * units and casts invalid numbers to 0.\r\n       *\r\n       * @param {string} value - The style value to parse.\r\n       *\r\n       * @returns {number} A valid number.\r\n       */\r\n      parseStyle: function(value) {\r\n        value = parseFloat(value);\r\n        return isFinite(value) ? value : 0;\r\n      },\r\n\r\n      /**\r\n       * Provides the closest positioned ancestor.\r\n       *\r\n       * @param {element} element - The element to get the offest parent for.\r\n       *\r\n       * @returns {element} The closest positioned ancestor.\r\n       */\r\n      offsetParent: function(elem) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\r\n\r\n        function isStaticPositioned(el) {\r\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\r\n        }\r\n\r\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\r\n          offsetParent = offsetParent.offsetParent;\r\n        }\r\n\r\n        return offsetParent || $document[0].documentElement;\r\n      },\r\n\r\n      /**\r\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\r\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\r\n       * In IE and Edge, scollbar on body and html element overlay and should\r\n       * return a width of 0.\r\n       *\r\n       * @returns {number} The width of the browser scollbar.\r\n       */\r\n      scrollbarWidth: function(isBody) {\r\n        if (isBody) {\r\n          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {\r\n            var bodyElem = $document.find('body');\r\n            bodyElem.addClass('uib-position-body-scrollbar-measure');\r\n            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;\r\n            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;\r\n            bodyElem.removeClass('uib-position-body-scrollbar-measure');\r\n          }\r\n          return BODY_SCROLLBAR_WIDTH;\r\n        }\r\n\r\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\r\n          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\r\n          $document.find('body').append(scrollElem);\r\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\r\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\r\n          scrollElem.remove();\r\n        }\r\n\r\n        return SCROLLBAR_WIDTH;\r\n      },\r\n\r\n      /**\r\n       * Provides the padding required on an element to replace the scrollbar.\r\n       *\r\n       * @returns {object} An object with the following properties:\r\n       *   <ul>\r\n       *     <li>**scrollbarWidth**: the width of the scrollbar</li>\r\n       *     <li>**widthOverflow**: whether the the width is overflowing</li>\r\n       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>\r\n       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>\r\n       *     <li>**heightOverflow**: whether the the height is overflowing</li>\r\n       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>\r\n       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>\r\n       *   </ul>\r\n       */\r\n      scrollbarPadding: function(elem) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var elemStyle = $window.getComputedStyle(elem);\r\n        var paddingRight = this.parseStyle(elemStyle.paddingRight);\r\n        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);\r\n        var scrollParent = this.scrollParent(elem, false, true);\r\n        var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));\r\n\r\n        return {\r\n          scrollbarWidth: scrollbarWidth,\r\n          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,\r\n          right: paddingRight + scrollbarWidth,\r\n          originalRight: paddingRight,\r\n          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,\r\n          bottom: paddingBottom + scrollbarWidth,\r\n          originalBottom: paddingBottom\r\n         };\r\n      },\r\n\r\n      /**\r\n       * Checks to see if the element is scrollable.\r\n       *\r\n       * @param {element} elem - The element to check.\r\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\r\n       *   default is false.\r\n       *\r\n       * @returns {boolean} Whether the element is scrollable.\r\n       */\r\n      isScrollable: function(elem, includeHidden) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\r\n        var elemStyle = $window.getComputedStyle(elem);\r\n        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\r\n      },\r\n\r\n      /**\r\n       * Provides the closest scrollable ancestor.\r\n       * A port of the jQuery UI scrollParent method:\r\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\r\n       *\r\n       * @param {element} elem - The element to find the scroll parent of.\r\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\r\n       *   default is false.\r\n       * @param {boolean=} [includeSelf=false] - Should the element being passed be\r\n       * included in the scrollable llokup.\r\n       *\r\n       * @returns {element} A HTML element.\r\n       */\r\n      scrollParent: function(elem, includeHidden, includeSelf) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\r\n        var documentEl = $document[0].documentElement;\r\n        var elemStyle = $window.getComputedStyle(elem);\r\n        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {\r\n          return elem;\r\n        }\r\n        var excludeStatic = elemStyle.position === 'absolute';\r\n        var scrollParent = elem.parentElement || documentEl;\r\n\r\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\r\n          return documentEl;\r\n        }\r\n\r\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\r\n          var spStyle = $window.getComputedStyle(scrollParent);\r\n          if (excludeStatic && spStyle.position !== 'static') {\r\n            excludeStatic = false;\r\n          }\r\n\r\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\r\n            break;\r\n          }\r\n          scrollParent = scrollParent.parentElement;\r\n        }\r\n\r\n        return scrollParent;\r\n      },\r\n\r\n      /**\r\n       * Provides read-only equivalent of jQuery's position function:\r\n       * http://api.jquery.com/position/ - distance to closest positioned\r\n       * ancestor.  Does not account for margins by default like jQuery position.\r\n       *\r\n       * @param {element} elem - The element to caclulate the position on.\r\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\r\n       * for, default is false.\r\n       *\r\n       * @returns {object} An object with the following properties:\r\n       *   <ul>\r\n       *     <li>**width**: the width of the element</li>\r\n       *     <li>**height**: the height of the element</li>\r\n       *     <li>**top**: distance to top edge of offset parent</li>\r\n       *     <li>**left**: distance to left edge of offset parent</li>\r\n       *   </ul>\r\n       */\r\n      position: function(elem, includeMagins) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var elemOffset = this.offset(elem);\r\n        if (includeMagins) {\r\n          var elemStyle = $window.getComputedStyle(elem);\r\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\r\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\r\n        }\r\n        var parent = this.offsetParent(elem);\r\n        var parentOffset = {top: 0, left: 0};\r\n\r\n        if (parent !== $document[0].documentElement) {\r\n          parentOffset = this.offset(parent);\r\n          parentOffset.top += parent.clientTop - parent.scrollTop;\r\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\r\n        }\r\n\r\n        return {\r\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\r\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\r\n          top: Math.round(elemOffset.top - parentOffset.top),\r\n          left: Math.round(elemOffset.left - parentOffset.left)\r\n        };\r\n      },\r\n\r\n      /**\r\n       * Provides read-only equivalent of jQuery's offset function:\r\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\r\n       * not account for borders, margins, or padding on the body\r\n       * element.\r\n       *\r\n       * @param {element} elem - The element to calculate the offset on.\r\n       *\r\n       * @returns {object} An object with the following properties:\r\n       *   <ul>\r\n       *     <li>**width**: the width of the element</li>\r\n       *     <li>**height**: the height of the element</li>\r\n       *     <li>**top**: distance to top edge of viewport</li>\r\n       *     <li>**right**: distance to bottom edge of viewport</li>\r\n       *   </ul>\r\n       */\r\n      offset: function(elem) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var elemBCR = elem.getBoundingClientRect();\r\n        return {\r\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\r\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\r\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\r\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\r\n        };\r\n      },\r\n\r\n      /**\r\n       * Provides offset distance to the closest scrollable ancestor\r\n       * or viewport.  Accounts for border and scrollbar width.\r\n       *\r\n       * Right and bottom dimensions represent the distance to the\r\n       * respective edge of the viewport element.  If the element\r\n       * edge extends beyond the viewport, a negative value will be\r\n       * reported.\r\n       *\r\n       * @param {element} elem - The element to get the viewport offset for.\r\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\r\n       * of the first scrollable element, default is false.\r\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\r\n       * be accounted for, default is true.\r\n       *\r\n       * @returns {object} An object with the following properties:\r\n       *   <ul>\r\n       *     <li>**top**: distance to the top content edge of viewport element</li>\r\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\r\n       *     <li>**left**: distance to the left content edge of viewport element</li>\r\n       *     <li>**right**: distance to the right content edge of viewport element</li>\r\n       *   </ul>\r\n       */\r\n      viewportOffset: function(elem, useDocument, includePadding) {\r\n        elem = this.getRawNode(elem);\r\n        includePadding = includePadding !== false ? true : false;\r\n\r\n        var elemBCR = elem.getBoundingClientRect();\r\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\r\n\r\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\r\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\r\n\r\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\r\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\r\n        if (offsetParent === $document[0].documentElement) {\r\n          offsetBCR.top += $window.pageYOffset;\r\n          offsetBCR.left += $window.pageXOffset;\r\n        }\r\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\r\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\r\n\r\n        if (includePadding) {\r\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\r\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\r\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\r\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\r\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\r\n        }\r\n\r\n        return {\r\n          top: Math.round(elemBCR.top - offsetBCR.top),\r\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\r\n          left: Math.round(elemBCR.left - offsetBCR.left),\r\n          right: Math.round(offsetBCR.right - elemBCR.right)\r\n        };\r\n      },\r\n\r\n      /**\r\n       * Provides an array of placement values parsed from a placement string.\r\n       * Along with the 'auto' indicator, supported placement strings are:\r\n       *   <ul>\r\n       *     <li>top: element on top, horizontally centered on host element.</li>\r\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\r\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\r\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\r\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\r\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\r\n       *     <li>left: element on left, vertically centered on host element.</li>\r\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\r\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\r\n       *     <li>right: element on right, vertically centered on host element.</li>\r\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\r\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\r\n       *   </ul>\r\n       * A placement string with an 'auto' indicator is expected to be\r\n       * space separated from the placement, i.e: 'auto bottom-left'  If\r\n       * the primary and secondary placement values do not match 'top,\r\n       * bottom, left, right' then 'top' will be the primary placement and\r\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\r\n       * will be returned as the 3rd value of the array.\r\n       *\r\n       * @param {string} placement - The placement string to parse.\r\n       *\r\n       * @returns {array} An array with the following values\r\n       * <ul>\r\n       *   <li>**[0]**: The primary placement.</li>\r\n       *   <li>**[1]**: The secondary placement.</li>\r\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\r\n       * </ul>\r\n       */\r\n      parsePlacement: function(placement) {\r\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\r\n        if (autoPlace) {\r\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\r\n        }\r\n\r\n        placement = placement.split('-');\r\n\r\n        placement[0] = placement[0] || 'top';\r\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\r\n          placement[0] = 'top';\r\n        }\r\n\r\n        placement[1] = placement[1] || 'center';\r\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\r\n          placement[1] = 'center';\r\n        }\r\n\r\n        if (autoPlace) {\r\n          placement[2] = true;\r\n        } else {\r\n          placement[2] = false;\r\n        }\r\n\r\n        return placement;\r\n      },\r\n\r\n      /**\r\n       * Provides coordinates for an element to be positioned relative to\r\n       * another element.  Passing 'auto' as part of the placement parameter\r\n       * will enable smart placement - where the element fits. i.e:\r\n       * 'auto left-top' will check to see if there is enough space to the left\r\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\r\n       * top placement).  Available space is calculated using the viewportOffset\r\n       * function.\r\n       *\r\n       * @param {element} hostElem - The element to position against.\r\n       * @param {element} targetElem - The element to position.\r\n       * @param {string=} [placement=top] - The placement for the targetElem,\r\n       *   default is 'top'. 'center' is assumed as secondary placement for\r\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\r\n       *   <ul>\r\n       *     <li>top</li>\r\n       *     <li>top-right</li>\r\n       *     <li>top-left</li>\r\n       *     <li>bottom</li>\r\n       *     <li>bottom-left</li>\r\n       *     <li>bottom-right</li>\r\n       *     <li>left</li>\r\n       *     <li>left-top</li>\r\n       *     <li>left-bottom</li>\r\n       *     <li>right</li>\r\n       *     <li>right-top</li>\r\n       *     <li>right-bottom</li>\r\n       *   </ul>\r\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\r\n       *   be calculated from the body element, default is false.\r\n       *\r\n       * @returns {object} An object with the following properties:\r\n       *   <ul>\r\n       *     <li>**top**: Value for targetElem top.</li>\r\n       *     <li>**left**: Value for targetElem left.</li>\r\n       *     <li>**placement**: The resolved placement.</li>\r\n       *   </ul>\r\n       */\r\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\r\n        hostElem = this.getRawNode(hostElem);\r\n        targetElem = this.getRawNode(targetElem);\r\n\r\n        // need to read from prop to support tests.\r\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\r\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\r\n\r\n        placement = this.parsePlacement(placement);\r\n\r\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\r\n        var targetElemPos = {top: 0, left: 0, placement: ''};\r\n\r\n        if (placement[2]) {\r\n          var viewportOffset = this.viewportOffset(hostElem, appendToBody);\r\n\r\n          var targetElemStyle = $window.getComputedStyle(targetElem);\r\n          var adjustedSize = {\r\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\r\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\r\n          };\r\n\r\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\r\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\r\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\r\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\r\n                         placement[0];\r\n\r\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\r\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\r\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\r\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\r\n                         placement[1];\r\n\r\n          if (placement[1] === 'center') {\r\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\r\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\r\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\r\n                placement[1] = 'left';\r\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\r\n                placement[1] = 'right';\r\n              }\r\n            } else {\r\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\r\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\r\n                placement[1] = 'top';\r\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\r\n                placement[1] = 'bottom';\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        switch (placement[0]) {\r\n          case 'top':\r\n            targetElemPos.top = hostElemPos.top - targetHeight;\r\n            break;\r\n          case 'bottom':\r\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\r\n            break;\r\n          case 'left':\r\n            targetElemPos.left = hostElemPos.left - targetWidth;\r\n            break;\r\n          case 'right':\r\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\r\n            break;\r\n        }\r\n\r\n        switch (placement[1]) {\r\n          case 'top':\r\n            targetElemPos.top = hostElemPos.top;\r\n            break;\r\n          case 'bottom':\r\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\r\n            break;\r\n          case 'left':\r\n            targetElemPos.left = hostElemPos.left;\r\n            break;\r\n          case 'right':\r\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\r\n            break;\r\n          case 'center':\r\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\r\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\r\n            } else {\r\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\r\n            }\r\n            break;\r\n        }\r\n\r\n        targetElemPos.top = Math.round(targetElemPos.top);\r\n        targetElemPos.left = Math.round(targetElemPos.left);\r\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\r\n\r\n        return targetElemPos;\r\n      },\r\n\r\n      /**\r\n      * Provides a way for positioning tooltip & dropdown\r\n      * arrows when using placement options beyond the standard\r\n      * left, right, top, or bottom.\r\n      *\r\n      * @param {element} elem - The tooltip/dropdown element.\r\n      * @param {string} placement - The placement for the elem.\r\n      */\r\n      positionArrow: function(elem, placement) {\r\n        elem = this.getRawNode(elem);\r\n\r\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\r\n        if (!innerElem) {\r\n          return;\r\n        }\r\n\r\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\r\n\r\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\r\n        if (!arrowElem) {\r\n          return;\r\n        }\r\n\r\n        var arrowCss = {\r\n          top: '',\r\n          bottom: '',\r\n          left: '',\r\n          right: ''\r\n        };\r\n\r\n        placement = this.parsePlacement(placement);\r\n        if (placement[1] === 'center') {\r\n          // no adjustment necessary - just reset styles\r\n          angular.element(arrowElem).css(arrowCss);\r\n          return;\r\n        }\r\n\r\n        var borderProp = 'border-' + placement[0] + '-width';\r\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\r\n\r\n        var borderRadiusProp = 'border-';\r\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\r\n          borderRadiusProp += placement[0] + '-' + placement[1];\r\n        } else {\r\n          borderRadiusProp += placement[1] + '-' + placement[0];\r\n        }\r\n        borderRadiusProp += '-radius';\r\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\r\n\r\n        switch (placement[0]) {\r\n          case 'top':\r\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\r\n            break;\r\n          case 'bottom':\r\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\r\n            break;\r\n          case 'left':\r\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\r\n            break;\r\n          case 'right':\r\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\r\n            break;\r\n        }\r\n\r\n        arrowCss[placement[1]] = borderRadius;\r\n\r\n        angular.element(arrowElem).css(arrowCss);\r\n      }\r\n    };\r\n  }]);\r\n\r\nangular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])\r\n\r\n.value('$datepickerPopupLiteralWarning', true)\r\n\r\n.constant('uibDatepickerPopupConfig', {\r\n  altInputFormats: [],\r\n  appendToBody: false,\r\n  clearText: 'Clear',\r\n  closeOnDateSelection: true,\r\n  closeText: 'Done',\r\n  currentText: 'Today',\r\n  datepickerPopup: 'yyyy-MM-dd',\r\n  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',\r\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\r\n  html5Types: {\r\n    date: 'yyyy-MM-dd',\r\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\r\n    'month': 'yyyy-MM'\r\n  },\r\n  onOpenFocus: true,\r\n  showButtonBar: true,\r\n  placement: 'auto bottom-left'\r\n})\r\n\r\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',\r\nfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {\r\n  var cache = {},\r\n    isHtml5DateInput = false;\r\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\r\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\r\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [],\r\n    timezone;\r\n\r\n  this.init = function(_ngModel_) {\r\n    ngModel = _ngModel_;\r\n    ngModelOptions = _ngModel_.$options;\r\n    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\r\n      $scope.$parent.$eval($attrs.closeOnDateSelection) :\r\n      datepickerPopupConfig.closeOnDateSelection;\r\n    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\r\n      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\r\n      datepickerPopupConfig.appendToBody;\r\n    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\r\n      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\r\n    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\r\n      $attrs.datepickerPopupTemplateUrl :\r\n      datepickerPopupConfig.datepickerPopupTemplateUrl;\r\n    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\r\n      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\r\n    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\r\n      $scope.$parent.$eval($attrs.altInputFormats) :\r\n      datepickerPopupConfig.altInputFormats;\r\n\r\n    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\r\n      $scope.$parent.$eval($attrs.showButtonBar) :\r\n      datepickerPopupConfig.showButtonBar;\r\n\r\n    if (datepickerPopupConfig.html5Types[$attrs.type]) {\r\n      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\r\n      isHtml5DateInput = true;\r\n    } else {\r\n      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\r\n      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\r\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\r\n        // Invalidate the $modelValue to ensure that formatters re-run\r\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\r\n        if (newDateFormat !== dateFormat) {\r\n          dateFormat = newDateFormat;\r\n          ngModel.$modelValue = null;\r\n\r\n          if (!dateFormat) {\r\n            throw new Error('uibDatepickerPopup must have a date format specified.');\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    if (!dateFormat) {\r\n      throw new Error('uibDatepickerPopup must have a date format specified.');\r\n    }\r\n\r\n    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\r\n      throw new Error('HTML5 date input types do not support custom formats.');\r\n    }\r\n\r\n    // popup element used to display calendar\r\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\r\n    if (ngModelOptions) {\r\n      timezone = ngModelOptions.timezone;\r\n      $scope.ngModelOptions = angular.copy(ngModelOptions);\r\n      $scope.ngModelOptions.timezone = null;\r\n      if ($scope.ngModelOptions.updateOnDefault === true) {\r\n        $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ?\r\n          $scope.ngModelOptions.updateOn + ' default' : 'default';\r\n      }\r\n\r\n      popupEl.attr('ng-model-options', 'ngModelOptions');\r\n    } else {\r\n      timezone = null;\r\n    }\r\n\r\n    popupEl.attr({\r\n      'ng-model': 'date',\r\n      'ng-change': 'dateSelection(date)',\r\n      'template-url': datepickerPopupTemplateUrl\r\n    });\r\n\r\n    // datepicker element\r\n    datepickerEl = angular.element(popupEl.children()[0]);\r\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\r\n\r\n    if (!$scope.datepickerOptions) {\r\n      $scope.datepickerOptions = {};\r\n    }\r\n\r\n    if (isHtml5DateInput) {\r\n      if ($attrs.type === 'month') {\r\n        $scope.datepickerOptions.datepickerMode = 'month';\r\n        $scope.datepickerOptions.minMode = 'month';\r\n      }\r\n    }\r\n\r\n    datepickerEl.attr('datepicker-options', 'datepickerOptions');\r\n\r\n    if (!isHtml5DateInput) {\r\n      // Internal API to maintain the correct ng-invalid-[key] class\r\n      ngModel.$$parserName = 'date';\r\n      ngModel.$validators.date = validator;\r\n      ngModel.$parsers.unshift(parseDate);\r\n      ngModel.$formatters.push(function(value) {\r\n        if (ngModel.$isEmpty(value)) {\r\n          $scope.date = value;\r\n          return value;\r\n        }\r\n\r\n        if (angular.isNumber(value)) {\r\n          value = new Date(value);\r\n        }\r\n\r\n        $scope.date = dateParser.fromTimezone(value, timezone);\r\n\r\n        return dateParser.filter($scope.date, dateFormat);\r\n      });\r\n    } else {\r\n      ngModel.$formatters.push(function(value) {\r\n        $scope.date = dateParser.fromTimezone(value, timezone);\r\n        return value;\r\n      });\r\n    }\r\n\r\n    // Detect changes in the view from the text box\r\n    ngModel.$viewChangeListeners.push(function() {\r\n      $scope.date = parseDateString(ngModel.$viewValue);\r\n    });\r\n\r\n    $element.on('keydown', inputKeydownBind);\r\n\r\n    $popup = $compile(popupEl)($scope);\r\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\r\n    popupEl.remove();\r\n\r\n    if (appendToBody) {\r\n      $document.find('body').append($popup);\r\n    } else {\r\n      $element.after($popup);\r\n    }\r\n\r\n    $scope.$on('$destroy', function() {\r\n      if ($scope.isOpen === true) {\r\n        if (!$rootScope.$$phase) {\r\n          $scope.$apply(function() {\r\n            $scope.isOpen = false;\r\n          });\r\n        }\r\n      }\r\n\r\n      $popup.remove();\r\n      $element.off('keydown', inputKeydownBind);\r\n      $document.off('click', documentClickBind);\r\n      if (scrollParentEl) {\r\n        scrollParentEl.off('scroll', positionPopup);\r\n      }\r\n      angular.element($window).off('resize', positionPopup);\r\n\r\n      //Clear all watch listeners on destroy\r\n      while (watchListeners.length) {\r\n        watchListeners.shift()();\r\n      }\r\n    });\r\n  };\r\n\r\n  $scope.getText = function(key) {\r\n    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\r\n  };\r\n\r\n  $scope.isDisabled = function(date) {\r\n    if (date === 'today') {\r\n      date = dateParser.fromTimezone(new Date(), timezone);\r\n    }\r\n\r\n    var dates = {};\r\n    angular.forEach(['minDate', 'maxDate'], function(key) {\r\n      if (!$scope.datepickerOptions[key]) {\r\n        dates[key] = null;\r\n      } else if (angular.isDate($scope.datepickerOptions[key])) {\r\n        dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);\r\n      } else {\r\n        if ($datepickerPopupLiteralWarning) {\r\n          $log.warn('Literal date support has been deprecated, please switch to date object usage');\r\n        }\r\n\r\n        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));\r\n      }\r\n    });\r\n\r\n    return $scope.datepickerOptions &&\r\n      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||\r\n      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;\r\n  };\r\n\r\n  $scope.compare = function(date1, date2) {\r\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\r\n  };\r\n\r\n  // Inner change\r\n  $scope.dateSelection = function(dt) {\r\n    if (angular.isDefined(dt)) {\r\n      $scope.date = dt;\r\n    }\r\n    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\r\n    $element.val(date);\r\n    ngModel.$setViewValue(date);\r\n\r\n    if (closeOnDateSelection) {\r\n      $scope.isOpen = false;\r\n      $element[0].focus();\r\n    }\r\n  };\r\n\r\n  $scope.keydown = function(evt) {\r\n    if (evt.which === 27) {\r\n      evt.stopPropagation();\r\n      $scope.isOpen = false;\r\n      $element[0].focus();\r\n    }\r\n  };\r\n\r\n  $scope.select = function(date, evt) {\r\n    evt.stopPropagation();\r\n\r\n    if (date === 'today') {\r\n      var today = new Date();\r\n      if (angular.isDate($scope.date)) {\r\n        date = new Date($scope.date);\r\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\r\n      } else {\r\n        date = new Date(today.setHours(0, 0, 0, 0));\r\n      }\r\n    }\r\n    $scope.dateSelection(date);\r\n  };\r\n\r\n  $scope.close = function(evt) {\r\n    evt.stopPropagation();\r\n\r\n    $scope.isOpen = false;\r\n    $element[0].focus();\r\n  };\r\n\r\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\r\n  if ($attrs.ngDisabled) {\r\n    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\r\n      $scope.disabled = disabled;\r\n    }));\r\n  }\r\n\r\n  $scope.$watch('isOpen', function(value) {\r\n    if (value) {\r\n      if (!$scope.disabled) {\r\n        $timeout(function() {\r\n          positionPopup();\r\n\r\n          if (onOpenFocus) {\r\n            $scope.$broadcast('uib:datepicker.focus');\r\n          }\r\n\r\n          $document.on('click', documentClickBind);\r\n\r\n          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\r\n          if (appendToBody || $position.parsePlacement(placement)[2]) {\r\n            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\r\n            if (scrollParentEl) {\r\n              scrollParentEl.on('scroll', positionPopup);\r\n            }\r\n          } else {\r\n            scrollParentEl = null;\r\n          }\r\n\r\n          angular.element($window).on('resize', positionPopup);\r\n        }, 0, false);\r\n      } else {\r\n        $scope.isOpen = false;\r\n      }\r\n    } else {\r\n      $document.off('click', documentClickBind);\r\n      if (scrollParentEl) {\r\n        scrollParentEl.off('scroll', positionPopup);\r\n      }\r\n      angular.element($window).off('resize', positionPopup);\r\n    }\r\n  });\r\n\r\n  function cameltoDash(string) {\r\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\r\n  }\r\n\r\n  function parseDateString(viewValue) {\r\n    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\r\n    if (isNaN(date)) {\r\n      for (var i = 0; i < altInputFormats.length; i++) {\r\n        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\r\n        if (!isNaN(date)) {\r\n          return date;\r\n        }\r\n      }\r\n    }\r\n    return date;\r\n  }\r\n\r\n  function parseDate(viewValue) {\r\n    if (angular.isNumber(viewValue)) {\r\n      // presumably timestamp to date object\r\n      viewValue = new Date(viewValue);\r\n    }\r\n\r\n    if (!viewValue) {\r\n      return null;\r\n    }\r\n\r\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\r\n      return viewValue;\r\n    }\r\n\r\n    if (angular.isString(viewValue)) {\r\n      var date = parseDateString(viewValue);\r\n      if (!isNaN(date)) {\r\n        return dateParser.toTimezone(date, timezone);\r\n      }\r\n    }\r\n\r\n    return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;\r\n  }\r\n\r\n  function validator(modelValue, viewValue) {\r\n    var value = modelValue || viewValue;\r\n\r\n    if (!$attrs.ngRequired && !value) {\r\n      return true;\r\n    }\r\n\r\n    if (angular.isNumber(value)) {\r\n      value = new Date(value);\r\n    }\r\n\r\n    if (!value) {\r\n      return true;\r\n    }\r\n\r\n    if (angular.isDate(value) && !isNaN(value)) {\r\n      return true;\r\n    }\r\n\r\n    if (angular.isString(value)) {\r\n      return !isNaN(parseDateString(viewValue));\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function documentClickBind(event) {\r\n    if (!$scope.isOpen && $scope.disabled) {\r\n      return;\r\n    }\r\n\r\n    var popup = $popup[0];\r\n    var dpContainsTarget = $element[0].contains(event.target);\r\n    // The popup node may not be an element node\r\n    // In some browsers (IE) only element nodes have the 'contains' function\r\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\r\n    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\r\n      $scope.$apply(function() {\r\n        $scope.isOpen = false;\r\n      });\r\n    }\r\n  }\r\n\r\n  function inputKeydownBind(evt) {\r\n    if (evt.which === 27 && $scope.isOpen) {\r\n      evt.preventDefault();\r\n      evt.stopPropagation();\r\n      $scope.$apply(function() {\r\n        $scope.isOpen = false;\r\n      });\r\n      $element[0].focus();\r\n    } else if (evt.which === 40 && !$scope.isOpen) {\r\n      evt.preventDefault();\r\n      evt.stopPropagation();\r\n      $scope.$apply(function() {\r\n        $scope.isOpen = true;\r\n      });\r\n    }\r\n  }\r\n\r\n  function positionPopup() {\r\n    if ($scope.isOpen) {\r\n      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\r\n      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\r\n      var position = $position.positionElements($element, dpElement, placement, appendToBody);\r\n      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\r\n      if (dpElement.hasClass('uib-position-measure')) {\r\n        dpElement.removeClass('uib-position-measure');\r\n      }\r\n    }\r\n  }\r\n\r\n  $scope.$on('uib:datepicker.mode', function() {\r\n    $timeout(positionPopup, 0, false);\r\n  });\r\n}])\r\n\r\n.directive('uibDatepickerPopup', function() {\r\n  return {\r\n    require: ['ngModel', 'uibDatepickerPopup'],\r\n    controller: 'UibDatepickerPopupController',\r\n    scope: {\r\n      datepickerOptions: '=?',\r\n      isOpen: '=?',\r\n      currentText: '@',\r\n      clearText: '@',\r\n      closeText: '@'\r\n    },\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var ngModel = ctrls[0],\r\n        ctrl = ctrls[1];\r\n\r\n      ctrl.init(ngModel);\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibDatepickerPopupWrap', function() {\r\n  return {\r\n    replace: true,\r\n    transclude: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.debounce', [])\r\n/**\r\n * A helper, internal service that debounces a function\r\n */\r\n  .factory('$$debounce', ['$timeout', function($timeout) {\r\n    return function(callback, debounceTime) {\r\n      var timeoutPromise;\r\n\r\n      return function() {\r\n        var self = this;\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (timeoutPromise) {\r\n          $timeout.cancel(timeoutPromise);\r\n        }\r\n\r\n        timeoutPromise = $timeout(function() {\r\n          callback.apply(self, args);\r\n        }, debounceTime);\r\n      };\r\n    };\r\n  }]);\r\n\r\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])\r\n\r\n.constant('uibDropdownConfig', {\r\n  appendToOpenClass: 'uib-dropdown-open',\r\n  openClass: 'open'\r\n})\r\n\r\n.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {\r\n  var openScope = null;\r\n\r\n  this.open = function(dropdownScope, element) {\r\n    if (!openScope) {\r\n      $document.on('click', closeDropdown);\r\n      element.on('keydown', keybindFilter);\r\n    }\r\n\r\n    if (openScope && openScope !== dropdownScope) {\r\n      openScope.isOpen = false;\r\n    }\r\n\r\n    openScope = dropdownScope;\r\n  };\r\n\r\n  this.close = function(dropdownScope, element) {\r\n    if (openScope === dropdownScope) {\r\n      openScope = null;\r\n      $document.off('click', closeDropdown);\r\n      element.off('keydown', keybindFilter);\r\n    }\r\n  };\r\n\r\n  var closeDropdown = function(evt) {\r\n    // This method may still be called during the same mouse event that\r\n    // unbound this event handler. So check openScope before proceeding.\r\n    if (!openScope) { return; }\r\n\r\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\r\n\r\n    if (evt && evt.which === 3) { return; }\r\n\r\n    var toggleElement = openScope.getToggleElement();\r\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\r\n      return;\r\n    }\r\n\r\n    var dropdownElement = openScope.getDropdownElement();\r\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\r\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\r\n      return;\r\n    }\r\n\r\n    openScope.isOpen = false;\r\n\r\n    if (!$rootScope.$$phase) {\r\n      openScope.$apply();\r\n    }\r\n  };\r\n\r\n  var keybindFilter = function(evt) {\r\n    if (evt.which === 27) {\r\n      evt.stopPropagation();\r\n      openScope.focusToggleElement();\r\n      closeDropdown();\r\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen) {\r\n      evt.preventDefault();\r\n      evt.stopPropagation();\r\n      openScope.focusDropdownEntry(evt.which);\r\n    }\r\n  };\r\n}])\r\n\r\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\r\n  var self = this,\r\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\r\n    templateScope,\r\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\r\n    openClass = dropdownConfig.openClass,\r\n    getIsOpen,\r\n    setIsOpen = angular.noop,\r\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\r\n    appendToBody = false,\r\n    appendTo = null,\r\n    keynavEnabled = false,\r\n    selectedOption = null,\r\n    body = $document.find('body');\r\n\r\n  $element.addClass('dropdown');\r\n\r\n  this.init = function() {\r\n    if ($attrs.isOpen) {\r\n      getIsOpen = $parse($attrs.isOpen);\r\n      setIsOpen = getIsOpen.assign;\r\n\r\n      $scope.$watch(getIsOpen, function(value) {\r\n        scope.isOpen = !!value;\r\n      });\r\n    }\r\n\r\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\r\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\r\n      if (appendToEl) {\r\n        appendTo = angular.element(appendToEl);\r\n      }\r\n    }\r\n\r\n    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);\r\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\r\n\r\n    if (appendToBody && !appendTo) {\r\n      appendTo = body;\r\n    }\r\n\r\n    if (appendTo && self.dropdownMenu) {\r\n      appendTo.append(self.dropdownMenu);\r\n      $element.on('$destroy', function handleDestroyEvent() {\r\n        self.dropdownMenu.remove();\r\n      });\r\n    }\r\n  };\r\n\r\n  this.toggle = function(open) {\r\n    scope.isOpen = arguments.length ? !!open : !scope.isOpen;\r\n    if (angular.isFunction(setIsOpen)) {\r\n      setIsOpen(scope, scope.isOpen);\r\n    }\r\n\r\n    return scope.isOpen;\r\n  };\r\n\r\n  // Allow other directives to watch status\r\n  this.isOpen = function() {\r\n    return scope.isOpen;\r\n  };\r\n\r\n  scope.getToggleElement = function() {\r\n    return self.toggleElement;\r\n  };\r\n\r\n  scope.getAutoClose = function() {\r\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\r\n  };\r\n\r\n  scope.getElement = function() {\r\n    return $element;\r\n  };\r\n\r\n  scope.isKeynavEnabled = function() {\r\n    return keynavEnabled;\r\n  };\r\n\r\n  scope.focusDropdownEntry = function(keyCode) {\r\n    var elems = self.dropdownMenu ? //If append to body is used.\r\n      angular.element(self.dropdownMenu).find('a') :\r\n      $element.find('ul').eq(0).find('a');\r\n\r\n    switch (keyCode) {\r\n      case 40: {\r\n        if (!angular.isNumber(self.selectedOption)) {\r\n          self.selectedOption = 0;\r\n        } else {\r\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\r\n            self.selectedOption :\r\n            self.selectedOption + 1;\r\n        }\r\n        break;\r\n      }\r\n      case 38: {\r\n        if (!angular.isNumber(self.selectedOption)) {\r\n          self.selectedOption = elems.length - 1;\r\n        } else {\r\n          self.selectedOption = self.selectedOption === 0 ?\r\n            0 : self.selectedOption - 1;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n    elems[self.selectedOption].focus();\r\n  };\r\n\r\n  scope.getDropdownElement = function() {\r\n    return self.dropdownMenu;\r\n  };\r\n\r\n  scope.focusToggleElement = function() {\r\n    if (self.toggleElement) {\r\n      self.toggleElement[0].focus();\r\n    }\r\n  };\r\n\r\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\r\n    if (appendTo && self.dropdownMenu) {\r\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\r\n        css,\r\n        rightalign,\r\n        scrollbarWidth;\r\n\r\n      css = {\r\n        top: pos.top + 'px',\r\n        display: isOpen ? 'block' : 'none'\r\n      };\r\n\r\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\r\n      if (!rightalign) {\r\n        css.left = pos.left + 'px';\r\n        css.right = 'auto';\r\n      } else {\r\n        css.left = 'auto';\r\n        scrollbarWidth = $position.scrollbarWidth(true);\r\n        css.right = window.innerWidth - scrollbarWidth -\r\n          (pos.left + $element.prop('offsetWidth')) + 'px';\r\n      }\r\n\r\n      // Need to adjust our positioning to be relative to the appendTo container\r\n      // if it's not the body element\r\n      if (!appendToBody) {\r\n        var appendOffset = $position.offset(appendTo);\r\n\r\n        css.top = pos.top - appendOffset.top + 'px';\r\n\r\n        if (!rightalign) {\r\n          css.left = pos.left - appendOffset.left + 'px';\r\n        } else {\r\n          css.right = window.innerWidth -\r\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\r\n        }\r\n      }\r\n\r\n      self.dropdownMenu.css(css);\r\n    }\r\n\r\n    var openContainer = appendTo ? appendTo : $element;\r\n    var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);\r\n\r\n    if (hasOpenClass === !isOpen) {\r\n      $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {\r\n        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\r\n          toggleInvoker($scope, { open: !!isOpen });\r\n        }\r\n      });\r\n    }\r\n\r\n    if (isOpen) {\r\n      if (self.dropdownMenuTemplateUrl) {\r\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\r\n          templateScope = scope.$new();\r\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\r\n            var newEl = dropdownElement;\r\n            self.dropdownMenu.replaceWith(newEl);\r\n            self.dropdownMenu = newEl;\r\n          });\r\n        });\r\n      }\r\n\r\n      scope.focusToggleElement();\r\n      uibDropdownService.open(scope, $element);\r\n    } else {\r\n      if (self.dropdownMenuTemplateUrl) {\r\n        if (templateScope) {\r\n          templateScope.$destroy();\r\n        }\r\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\r\n        self.dropdownMenu.replaceWith(newEl);\r\n        self.dropdownMenu = newEl;\r\n      }\r\n\r\n      uibDropdownService.close(scope, $element);\r\n      self.selectedOption = null;\r\n    }\r\n\r\n    if (angular.isFunction(setIsOpen)) {\r\n      setIsOpen($scope, isOpen);\r\n    }\r\n  });\r\n}])\r\n\r\n.directive('uibDropdown', function() {\r\n  return {\r\n    controller: 'UibDropdownController',\r\n    link: function(scope, element, attrs, dropdownCtrl) {\r\n      dropdownCtrl.init();\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibDropdownMenu', function() {\r\n  return {\r\n    restrict: 'A',\r\n    require: '?^uibDropdown',\r\n    link: function(scope, element, attrs, dropdownCtrl) {\r\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\r\n        return;\r\n      }\r\n\r\n      element.addClass('dropdown-menu');\r\n\r\n      var tplUrl = attrs.templateUrl;\r\n      if (tplUrl) {\r\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\r\n      }\r\n\r\n      if (!dropdownCtrl.dropdownMenu) {\r\n        dropdownCtrl.dropdownMenu = element;\r\n      }\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibDropdownToggle', function() {\r\n  return {\r\n    require: '?^uibDropdown',\r\n    link: function(scope, element, attrs, dropdownCtrl) {\r\n      if (!dropdownCtrl) {\r\n        return;\r\n      }\r\n\r\n      element.addClass('dropdown-toggle');\r\n\r\n      dropdownCtrl.toggleElement = element;\r\n\r\n      var toggleDropdown = function(event) {\r\n        event.preventDefault();\r\n\r\n        if (!element.hasClass('disabled') && !attrs.disabled) {\r\n          scope.$apply(function() {\r\n            dropdownCtrl.toggle();\r\n          });\r\n        }\r\n      };\r\n\r\n      element.bind('click', toggleDropdown);\r\n\r\n      // WAI-ARIA\r\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\r\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\r\n        element.attr('aria-expanded', !!isOpen);\r\n      });\r\n\r\n      scope.$on('$destroy', function() {\r\n        element.unbind('click', toggleDropdown);\r\n      });\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.stackedMap', [])\r\n/**\r\n * A helper, internal data structure that acts as a map but also allows getting / removing\r\n * elements in the LIFO order\r\n */\r\n  .factory('$$stackedMap', function() {\r\n    return {\r\n      createNew: function() {\r\n        var stack = [];\r\n\r\n        return {\r\n          add: function(key, value) {\r\n            stack.push({\r\n              key: key,\r\n              value: value\r\n            });\r\n          },\r\n          get: function(key) {\r\n            for (var i = 0; i < stack.length; i++) {\r\n              if (key === stack[i].key) {\r\n                return stack[i];\r\n              }\r\n            }\r\n          },\r\n          keys: function() {\r\n            var keys = [];\r\n            for (var i = 0; i < stack.length; i++) {\r\n              keys.push(stack[i].key);\r\n            }\r\n            return keys;\r\n          },\r\n          top: function() {\r\n            return stack[stack.length - 1];\r\n          },\r\n          remove: function(key) {\r\n            var idx = -1;\r\n            for (var i = 0; i < stack.length; i++) {\r\n              if (key === stack[i].key) {\r\n                idx = i;\r\n                break;\r\n              }\r\n            }\r\n            return stack.splice(idx, 1)[0];\r\n          },\r\n          removeTop: function() {\r\n            return stack.splice(stack.length - 1, 1)[0];\r\n          },\r\n          length: function() {\r\n            return stack.length;\r\n          }\r\n        };\r\n      }\r\n    };\r\n  });\r\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap', 'ui.bootstrap.position'])\r\n/**\r\n * A helper, internal data structure that stores all references attached to key\r\n */\r\n  .factory('$$multiMap', function() {\r\n    return {\r\n      createNew: function() {\r\n        var map = {};\r\n\r\n        return {\r\n          entries: function() {\r\n            return Object.keys(map).map(function(key) {\r\n              return {\r\n                key: key,\r\n                value: map[key]\r\n              };\r\n            });\r\n          },\r\n          get: function(key) {\r\n            return map[key];\r\n          },\r\n          hasKey: function(key) {\r\n            return !!map[key];\r\n          },\r\n          keys: function() {\r\n            return Object.keys(map);\r\n          },\r\n          put: function(key, value) {\r\n            if (!map[key]) {\r\n              map[key] = [];\r\n            }\r\n\r\n            map[key].push(value);\r\n          },\r\n          remove: function(key, value) {\r\n            var values = map[key];\r\n\r\n            if (!values) {\r\n              return;\r\n            }\r\n\r\n            var idx = values.indexOf(value);\r\n\r\n            if (idx !== -1) {\r\n              values.splice(idx, 1);\r\n            }\r\n\r\n            if (!values.length) {\r\n              delete map[key];\r\n            }\r\n          }\r\n        };\r\n      }\r\n    };\r\n  })\r\n\r\n/**\r\n * Pluggable resolve mechanism for the modal resolve resolution\r\n * Supports UI Router's $resolve service\r\n */\r\n  .provider('$uibResolve', function() {\r\n    var resolve = this;\r\n    this.resolver = null;\r\n\r\n    this.setResolver = function(resolver) {\r\n      this.resolver = resolver;\r\n    };\r\n\r\n    this.$get = ['$injector', '$q', function($injector, $q) {\r\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\r\n      return {\r\n        resolve: function(invocables, locals, parent, self) {\r\n          if (resolver) {\r\n            return resolver.resolve(invocables, locals, parent, self);\r\n          }\r\n\r\n          var promises = [];\r\n\r\n          angular.forEach(invocables, function(value) {\r\n            if (angular.isFunction(value) || angular.isArray(value)) {\r\n              promises.push($q.resolve($injector.invoke(value)));\r\n            } else if (angular.isString(value)) {\r\n              promises.push($q.resolve($injector.get(value)));\r\n            } else {\r\n              promises.push($q.resolve(value));\r\n            }\r\n          });\r\n\r\n          return $q.all(promises).then(function(resolves) {\r\n            var resolveObj = {};\r\n            var resolveIter = 0;\r\n            angular.forEach(invocables, function(value, key) {\r\n              resolveObj[key] = resolves[resolveIter++];\r\n            });\r\n\r\n            return resolveObj;\r\n          });\r\n        }\r\n      };\r\n    }];\r\n  })\r\n\r\n/**\r\n * A helper directive for the $modal service. It creates a backdrop element.\r\n */\r\n  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',\r\n  function($animate, $injector, $modalStack) {\r\n    return {\r\n      replace: true,\r\n      templateUrl: 'uib/template/modal/backdrop.html',\r\n      compile: function(tElement, tAttrs) {\r\n        tElement.addClass(tAttrs.backdropClass);\r\n        return linkFn;\r\n      }\r\n    };\r\n\r\n    function linkFn(scope, element, attrs) {\r\n      if (attrs.modalInClass) {\r\n        $animate.addClass(element, attrs.modalInClass);\r\n\r\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\r\n          var done = setIsAsync();\r\n          if (scope.modalOptions.animation) {\r\n            $animate.removeClass(element, attrs.modalInClass).then(done);\r\n          } else {\r\n            done();\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }])\r\n\r\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',\r\n  function($modalStack, $q, $animateCss, $document) {\r\n    return {\r\n      scope: {\r\n        index: '@'\r\n      },\r\n      replace: true,\r\n      transclude: true,\r\n      templateUrl: function(tElement, tAttrs) {\r\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\r\n      },\r\n      link: function(scope, element, attrs) {\r\n        element.addClass(attrs.windowClass || '');\r\n        element.addClass(attrs.windowTopClass || '');\r\n        scope.size = attrs.size;\r\n\r\n        scope.close = function(evt) {\r\n          var modal = $modalStack.getTop();\r\n          if (modal && modal.value.backdrop &&\r\n            modal.value.backdrop !== 'static' &&\r\n            evt.target === evt.currentTarget) {\r\n            evt.preventDefault();\r\n            evt.stopPropagation();\r\n            $modalStack.dismiss(modal.key, 'backdrop click');\r\n          }\r\n        };\r\n\r\n        // moved from template to fix issue #2280\r\n        element.on('click', scope.close);\r\n\r\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\r\n        // We can detect that by using this property in the template associated with this directive and then use\r\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\r\n        scope.$isRendered = true;\r\n\r\n        // Deferred object that will be resolved when this modal is render.\r\n        var modalRenderDeferObj = $q.defer();\r\n        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.\r\n        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.\r\n        attrs.$observe('modalRender', function(value) {\r\n          if (value === 'true') {\r\n            modalRenderDeferObj.resolve();\r\n          }\r\n        });\r\n\r\n        modalRenderDeferObj.promise.then(function() {\r\n          var animationPromise = null;\r\n\r\n          if (attrs.modalInClass) {\r\n            animationPromise = $animateCss(element, {\r\n              addClass: attrs.modalInClass\r\n            }).start();\r\n\r\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\r\n              var done = setIsAsync();\r\n              $animateCss(element, {\r\n                removeClass: attrs.modalInClass\r\n              }).start().then(done);\r\n            });\r\n          }\r\n\r\n\r\n          $q.when(animationPromise).then(function() {\r\n            // Notify {@link $modalStack} that modal is rendered.\r\n            var modal = $modalStack.getTop();\r\n            if (modal) {\r\n              $modalStack.modalRendered(modal.key);\r\n            }\r\n\r\n            /**\r\n             * If something within the freshly-opened modal already has focus (perhaps via a\r\n             * directive that causes focus). then no need to try and focus anything.\r\n             */\r\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\r\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\r\n              /**\r\n               * Auto-focusing of a freshly-opened modal element causes any child elements\r\n               * with the autofocus attribute to lose focus. This is an issue on touch\r\n               * based devices which will show and then hide the onscreen keyboard.\r\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\r\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\r\n               * the modal element if the modal does not contain an autofocus element.\r\n               */\r\n              if (inputWithAutofocus) {\r\n                inputWithAutofocus.focus();\r\n              } else {\r\n                element[0].focus();\r\n              }\r\n            }\r\n          });\r\n        });\r\n      }\r\n    };\r\n  }])\r\n\r\n  .directive('uibModalAnimationClass', function() {\r\n    return {\r\n      compile: function(tElement, tAttrs) {\r\n        if (tAttrs.modalAnimation) {\r\n          tElement.addClass(tAttrs.uibModalAnimationClass);\r\n        }\r\n      }\r\n    };\r\n  })\r\n\r\n  .directive('uibModalTransclude', function() {\r\n    return {\r\n      link: function(scope, element, attrs, controller, transclude) {\r\n        transclude(scope.$parent, function(clone) {\r\n          element.empty();\r\n          element.append(clone);\r\n        });\r\n      }\r\n    };\r\n  })\r\n\r\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\r\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',\r\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {\r\n      var OPENED_MODAL_CLASS = 'modal-open';\r\n\r\n      var backdropDomEl, backdropScope;\r\n      var openedWindows = $$stackedMap.createNew();\r\n      var openedClasses = $$multiMap.createNew();\r\n      var $modalStack = {\r\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\r\n      };\r\n      var topModalIndex = 0;\r\n      var previousTopOpenedModal = null;\r\n\r\n      //Modal focus behavior\r\n      var tabableSelector = 'a[href], area[href], input:not([disabled]), ' +\r\n        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +\r\n        'iframe, object, embed, *[tabindex], *[contenteditable=true]';\r\n      var scrollbarPadding;\r\n\r\n      function isVisible(element) {\r\n        return !!(element.offsetWidth ||\r\n          element.offsetHeight ||\r\n          element.getClientRects().length);\r\n      }\r\n\r\n      function backdropIndex() {\r\n        var topBackdropIndex = -1;\r\n        var opened = openedWindows.keys();\r\n        for (var i = 0; i < opened.length; i++) {\r\n          if (openedWindows.get(opened[i]).value.backdrop) {\r\n            topBackdropIndex = i;\r\n          }\r\n        }\r\n\r\n        // If any backdrop exist, ensure that it's index is always\r\n        // right below the top modal\r\n        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {\r\n          topBackdropIndex = topModalIndex;\r\n        }\r\n        return topBackdropIndex;\r\n      }\r\n\r\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\r\n        if (backdropScope) {\r\n          backdropScope.index = newBackdropIndex;\r\n        }\r\n      });\r\n\r\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\r\n        var modalWindow = openedWindows.get(modalInstance).value;\r\n        var appendToElement = modalWindow.appendTo;\r\n\r\n        //clean up the stack\r\n        openedWindows.remove(modalInstance);\r\n        previousTopOpenedModal = openedWindows.top();\r\n        if (previousTopOpenedModal) {\r\n          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);\r\n        }\r\n\r\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\r\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\r\n          openedClasses.remove(modalBodyClass, modalInstance);\r\n          var areAnyOpen = openedClasses.hasKey(modalBodyClass);\r\n          appendToElement.toggleClass(modalBodyClass, areAnyOpen);\r\n          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\r\n            if (scrollbarPadding.originalRight) {\r\n              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});\r\n            } else {\r\n              appendToElement.css({paddingRight: ''});\r\n            }\r\n            scrollbarPadding = null;\r\n          }\r\n          toggleTopWindowClass(true);\r\n        }, modalWindow.closedDeferred);\r\n        checkRemoveBackdrop();\r\n\r\n        //move focus to specified element if available, or else to body\r\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\r\n          elementToReceiveFocus.focus();\r\n        } else if (appendToElement.focus) {\r\n          appendToElement.focus();\r\n        }\r\n      }\r\n\r\n      // Add or remove \"windowTopClass\" from the top window in the stack\r\n      function toggleTopWindowClass(toggleSwitch) {\r\n        var modalWindow;\r\n\r\n        if (openedWindows.length() > 0) {\r\n          modalWindow = openedWindows.top().value;\r\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\r\n        }\r\n      }\r\n\r\n      function checkRemoveBackdrop() {\r\n        //remove backdrop if no longer needed\r\n        if (backdropDomEl && backdropIndex() === -1) {\r\n          var backdropScopeRef = backdropScope;\r\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\r\n            backdropScopeRef = null;\r\n          });\r\n          backdropDomEl = undefined;\r\n          backdropScope = undefined;\r\n        }\r\n      }\r\n\r\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\r\n        var asyncDeferred;\r\n        var asyncPromise = null;\r\n        var setIsAsync = function() {\r\n          if (!asyncDeferred) {\r\n            asyncDeferred = $q.defer();\r\n            asyncPromise = asyncDeferred.promise;\r\n          }\r\n\r\n          return function asyncDone() {\r\n            asyncDeferred.resolve();\r\n          };\r\n        };\r\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\r\n\r\n        // Note that it's intentional that asyncPromise might be null.\r\n        // That's when setIsAsync has not been called during the\r\n        // NOW_CLOSING_EVENT broadcast.\r\n        return $q.when(asyncPromise).then(afterAnimating);\r\n\r\n        function afterAnimating() {\r\n          if (afterAnimating.done) {\r\n            return;\r\n          }\r\n          afterAnimating.done = true;\r\n\r\n          $animate.leave(domEl).then(function() {\r\n            domEl.remove();\r\n            if (closedDeferred) {\r\n              closedDeferred.resolve();\r\n            }\r\n          });\r\n\r\n          scope.$destroy();\r\n          if (done) {\r\n            done();\r\n          }\r\n        }\r\n      }\r\n\r\n      $document.on('keydown', keydownListener);\r\n\r\n      $rootScope.$on('$destroy', function() {\r\n        $document.off('keydown', keydownListener);\r\n      });\r\n\r\n      function keydownListener(evt) {\r\n        if (evt.isDefaultPrevented()) {\r\n          return evt;\r\n        }\r\n\r\n        var modal = openedWindows.top();\r\n        if (modal) {\r\n          switch (evt.which) {\r\n            case 27: {\r\n              if (modal.value.keyboard) {\r\n                evt.preventDefault();\r\n                $rootScope.$apply(function() {\r\n                  $modalStack.dismiss(modal.key, 'escape key press');\r\n                });\r\n              }\r\n              break;\r\n            }\r\n            case 9: {\r\n              var list = $modalStack.loadFocusElementList(modal);\r\n              var focusChanged = false;\r\n              if (evt.shiftKey) {\r\n                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {\r\n                  focusChanged = $modalStack.focusLastFocusableElement(list);\r\n                }\r\n              } else {\r\n                if ($modalStack.isFocusInLastItem(evt, list)) {\r\n                  focusChanged = $modalStack.focusFirstFocusableElement(list);\r\n                }\r\n              }\r\n\r\n              if (focusChanged) {\r\n                evt.preventDefault();\r\n                evt.stopPropagation();\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      $modalStack.open = function(modalInstance, modal) {\r\n        var modalOpener = $document[0].activeElement,\r\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\r\n\r\n        toggleTopWindowClass(false);\r\n\r\n        // Store the current top first, to determine what index we ought to use\r\n        // for the current top modal\r\n        previousTopOpenedModal = openedWindows.top();\r\n\r\n        openedWindows.add(modalInstance, {\r\n          deferred: modal.deferred,\r\n          renderDeferred: modal.renderDeferred,\r\n          closedDeferred: modal.closedDeferred,\r\n          modalScope: modal.scope,\r\n          backdrop: modal.backdrop,\r\n          keyboard: modal.keyboard,\r\n          openedClass: modal.openedClass,\r\n          windowTopClass: modal.windowTopClass,\r\n          animation: modal.animation,\r\n          appendTo: modal.appendTo\r\n        });\r\n\r\n        openedClasses.put(modalBodyClass, modalInstance);\r\n\r\n        var appendToElement = modal.appendTo,\r\n            currBackdropIndex = backdropIndex();\r\n\r\n        if (!appendToElement.length) {\r\n          throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\r\n        }\r\n\r\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\r\n          backdropScope = $rootScope.$new(true);\r\n          backdropScope.modalOptions = modal;\r\n          backdropScope.index = currBackdropIndex;\r\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\r\n          backdropDomEl.attr('backdrop-class', modal.backdropClass);\r\n          if (modal.animation) {\r\n            backdropDomEl.attr('modal-animation', 'true');\r\n          }\r\n          $compile(backdropDomEl)(backdropScope);\r\n          $animate.enter(backdropDomEl, appendToElement);\r\n          scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);\r\n          if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\r\n            appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});\r\n          }\r\n        }\r\n\r\n        // Set the top modal index based on the index of the previous top modal\r\n        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;\r\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\r\n        angularDomEl.attr({\r\n          'template-url': modal.windowTemplateUrl,\r\n          'window-class': modal.windowClass,\r\n          'window-top-class': modal.windowTopClass,\r\n          'size': modal.size,\r\n          'index': topModalIndex,\r\n          'animate': 'animate'\r\n        }).html(modal.content);\r\n        if (modal.animation) {\r\n          angularDomEl.attr('modal-animation', 'true');\r\n        }\r\n\r\n        appendToElement.addClass(modalBodyClass);\r\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);\r\n\r\n        openedWindows.top().value.modalDomEl = angularDomEl;\r\n        openedWindows.top().value.modalOpener = modalOpener;\r\n      };\r\n\r\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\r\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\r\n      }\r\n\r\n      $modalStack.close = function(modalInstance, result) {\r\n        var modalWindow = openedWindows.get(modalInstance);\r\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\r\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\r\n          modalWindow.value.deferred.resolve(result);\r\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\r\n          return true;\r\n        }\r\n        return !modalWindow;\r\n      };\r\n\r\n      $modalStack.dismiss = function(modalInstance, reason) {\r\n        var modalWindow = openedWindows.get(modalInstance);\r\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\r\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\r\n          modalWindow.value.deferred.reject(reason);\r\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\r\n          return true;\r\n        }\r\n        return !modalWindow;\r\n      };\r\n\r\n      $modalStack.dismissAll = function(reason) {\r\n        var topModal = this.getTop();\r\n        while (topModal && this.dismiss(topModal.key, reason)) {\r\n          topModal = this.getTop();\r\n        }\r\n      };\r\n\r\n      $modalStack.getTop = function() {\r\n        return openedWindows.top();\r\n      };\r\n\r\n      $modalStack.modalRendered = function(modalInstance) {\r\n        var modalWindow = openedWindows.get(modalInstance);\r\n        if (modalWindow) {\r\n          modalWindow.value.renderDeferred.resolve();\r\n        }\r\n      };\r\n\r\n      $modalStack.focusFirstFocusableElement = function(list) {\r\n        if (list.length > 0) {\r\n          list[0].focus();\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      $modalStack.focusLastFocusableElement = function(list) {\r\n        if (list.length > 0) {\r\n          list[list.length - 1].focus();\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n\r\n      $modalStack.isModalFocused = function(evt, modalWindow) {\r\n        if (evt && modalWindow) {\r\n          var modalDomEl = modalWindow.value.modalDomEl;\r\n          if (modalDomEl && modalDomEl.length) {\r\n            return (evt.target || evt.srcElement) === modalDomEl[0];\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n\r\n      $modalStack.isFocusInFirstItem = function(evt, list) {\r\n        if (list.length > 0) {\r\n          return (evt.target || evt.srcElement) === list[0];\r\n        }\r\n        return false;\r\n      };\r\n\r\n      $modalStack.isFocusInLastItem = function(evt, list) {\r\n        if (list.length > 0) {\r\n          return (evt.target || evt.srcElement) === list[list.length - 1];\r\n        }\r\n        return false;\r\n      };\r\n\r\n      $modalStack.loadFocusElementList = function(modalWindow) {\r\n        if (modalWindow) {\r\n          var modalDomE1 = modalWindow.value.modalDomEl;\r\n          if (modalDomE1 && modalDomE1.length) {\r\n            var elements = modalDomE1[0].querySelectorAll(tabableSelector);\r\n            return elements ?\r\n              Array.prototype.filter.call(elements, function(element) {\r\n                return isVisible(element);\r\n              }) : elements;\r\n          }\r\n        }\r\n      };\r\n\r\n      return $modalStack;\r\n    }])\r\n\r\n  .provider('$uibModal', function() {\r\n    var $modalProvider = {\r\n      options: {\r\n        animation: true,\r\n        backdrop: true, //can also be false or 'static'\r\n        keyboard: true\r\n      },\r\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\r\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\r\n          var $modal = {};\r\n\r\n          function getTemplatePromise(options) {\r\n            return options.template ? $q.when(options.template) :\r\n              $templateRequest(angular.isFunction(options.templateUrl) ?\r\n                options.templateUrl() : options.templateUrl);\r\n          }\r\n\r\n          var promiseChain = null;\r\n          $modal.getPromiseChain = function() {\r\n            return promiseChain;\r\n          };\r\n\r\n          $modal.open = function(modalOptions) {\r\n            var modalResultDeferred = $q.defer();\r\n            var modalOpenedDeferred = $q.defer();\r\n            var modalClosedDeferred = $q.defer();\r\n            var modalRenderDeferred = $q.defer();\r\n\r\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\r\n            var modalInstance = {\r\n              result: modalResultDeferred.promise,\r\n              opened: modalOpenedDeferred.promise,\r\n              closed: modalClosedDeferred.promise,\r\n              rendered: modalRenderDeferred.promise,\r\n              close: function (result) {\r\n                return $modalStack.close(modalInstance, result);\r\n              },\r\n              dismiss: function (reason) {\r\n                return $modalStack.dismiss(modalInstance, reason);\r\n              }\r\n            };\r\n\r\n            //merge and clean up options\r\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\r\n            modalOptions.resolve = modalOptions.resolve || {};\r\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\r\n\r\n            //verify options\r\n            if (!modalOptions.template && !modalOptions.templateUrl) {\r\n              throw new Error('One of template or templateUrl options is required.');\r\n            }\r\n\r\n            var templateAndResolvePromise =\r\n              $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\r\n\r\n            function resolveWithTemplate() {\r\n              return templateAndResolvePromise;\r\n            }\r\n\r\n            // Wait for the resolution of the existing promise chain.\r\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\r\n            // Then add to $modalStack and resolve opened.\r\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\r\n            var samePromise;\r\n            samePromise = promiseChain = $q.all([promiseChain])\r\n              .then(resolveWithTemplate, resolveWithTemplate)\r\n              .then(function resolveSuccess(tplAndVars) {\r\n                var providedScope = modalOptions.scope || $rootScope;\r\n\r\n                var modalScope = providedScope.$new();\r\n                modalScope.$close = modalInstance.close;\r\n                modalScope.$dismiss = modalInstance.dismiss;\r\n\r\n                modalScope.$on('$destroy', function() {\r\n                  if (!modalScope.$$uibDestructionScheduled) {\r\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\r\n                  }\r\n                });\r\n\r\n                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};\r\n\r\n                //controllers\r\n                if (modalOptions.controller) {\r\n                  ctrlLocals.$scope = modalScope;\r\n                  ctrlLocals.$scope.$resolve = {};\r\n                  ctrlLocals.$uibModalInstance = modalInstance;\r\n                  angular.forEach(tplAndVars[1], function(value, key) {\r\n                    ctrlLocals[key] = value;\r\n                    ctrlLocals.$scope.$resolve[key] = value;\r\n                  });\r\n\r\n                  // the third param will make the controller instantiate later,private api\r\n                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126\r\n                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);\r\n                  if (modalOptions.controllerAs && modalOptions.bindToController) {\r\n                    ctrlInstance = ctrlInstantiate.instance;\r\n                    ctrlInstance.$close = modalScope.$close;\r\n                    ctrlInstance.$dismiss = modalScope.$dismiss;\r\n                    angular.extend(ctrlInstance, {\r\n                      $resolve: ctrlLocals.$scope.$resolve\r\n                    }, providedScope);\r\n                  }\r\n\r\n                  ctrlInstance = ctrlInstantiate();\r\n\r\n                  if (angular.isFunction(ctrlInstance.$onInit)) {\r\n                    ctrlInstance.$onInit();\r\n                  }\r\n                }\r\n\r\n                $modalStack.open(modalInstance, {\r\n                  scope: modalScope,\r\n                  deferred: modalResultDeferred,\r\n                  renderDeferred: modalRenderDeferred,\r\n                  closedDeferred: modalClosedDeferred,\r\n                  content: tplAndVars[0],\r\n                  animation: modalOptions.animation,\r\n                  backdrop: modalOptions.backdrop,\r\n                  keyboard: modalOptions.keyboard,\r\n                  backdropClass: modalOptions.backdropClass,\r\n                  windowTopClass: modalOptions.windowTopClass,\r\n                  windowClass: modalOptions.windowClass,\r\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\r\n                  size: modalOptions.size,\r\n                  openedClass: modalOptions.openedClass,\r\n                  appendTo: modalOptions.appendTo\r\n                });\r\n                modalOpenedDeferred.resolve(true);\r\n\r\n            }, function resolveError(reason) {\r\n              modalOpenedDeferred.reject(reason);\r\n              modalResultDeferred.reject(reason);\r\n            })['finally'](function() {\r\n              if (promiseChain === samePromise) {\r\n                promiseChain = null;\r\n              }\r\n            });\r\n\r\n            return modalInstance;\r\n          };\r\n\r\n          return $modal;\r\n        }\r\n      ]\r\n    };\r\n\r\n    return $modalProvider;\r\n  });\r\n\r\nangular.module('ui.bootstrap.paging', [])\r\n/**\r\n * Helper internal service for generating common controller code between the\r\n * pager and pagination components\r\n */\r\n.factory('uibPaging', ['$parse', function($parse) {\r\n  return {\r\n    create: function(ctrl, $scope, $attrs) {\r\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\r\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\r\n      ctrl._watchers = [];\r\n\r\n      ctrl.init = function(ngModelCtrl, config) {\r\n        ctrl.ngModelCtrl = ngModelCtrl;\r\n        ctrl.config = config;\r\n\r\n        ngModelCtrl.$render = function() {\r\n          ctrl.render();\r\n        };\r\n\r\n        if ($attrs.itemsPerPage) {\r\n          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\r\n            ctrl.itemsPerPage = parseInt(value, 10);\r\n            $scope.totalPages = ctrl.calculateTotalPages();\r\n            ctrl.updatePage();\r\n          }));\r\n        } else {\r\n          ctrl.itemsPerPage = config.itemsPerPage;\r\n        }\r\n\r\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\r\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\r\n            $scope.totalPages = ctrl.calculateTotalPages();\r\n            ctrl.updatePage();\r\n          }\r\n        });\r\n      };\r\n\r\n      ctrl.calculateTotalPages = function() {\r\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\r\n        return Math.max(totalPages || 0, 1);\r\n      };\r\n\r\n      ctrl.render = function() {\r\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\r\n      };\r\n\r\n      $scope.selectPage = function(page, evt) {\r\n        if (evt) {\r\n          evt.preventDefault();\r\n        }\r\n\r\n        var clickAllowed = !$scope.ngDisabled || !evt;\r\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\r\n          if (evt && evt.target) {\r\n            evt.target.blur();\r\n          }\r\n          ctrl.ngModelCtrl.$setViewValue(page);\r\n          ctrl.ngModelCtrl.$render();\r\n        }\r\n      };\r\n\r\n      $scope.getText = function(key) {\r\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\r\n      };\r\n\r\n      $scope.noPrevious = function() {\r\n        return $scope.page === 1;\r\n      };\r\n\r\n      $scope.noNext = function() {\r\n        return $scope.page === $scope.totalPages;\r\n      };\r\n\r\n      ctrl.updatePage = function() {\r\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\r\n\r\n        if ($scope.page > $scope.totalPages) {\r\n          $scope.selectPage($scope.totalPages);\r\n        } else {\r\n          ctrl.ngModelCtrl.$render();\r\n        }\r\n      };\r\n\r\n      $scope.$on('$destroy', function() {\r\n        while (ctrl._watchers.length) {\r\n          ctrl._watchers.shift()();\r\n        }\r\n      });\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging'])\r\n\r\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\r\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\r\n\r\n  uibPaging.create(this, $scope, $attrs);\r\n}])\r\n\r\n.constant('uibPagerConfig', {\r\n  itemsPerPage: 10,\r\n  previousText: '« Previous',\r\n  nextText: 'Next »',\r\n  align: true\r\n})\r\n\r\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\r\n  return {\r\n    scope: {\r\n      totalItems: '=',\r\n      previousText: '@',\r\n      nextText: '@',\r\n      ngDisabled: '='\r\n    },\r\n    require: ['uibPager', '?ngModel'],\r\n    controller: 'UibPagerController',\r\n    controllerAs: 'pager',\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\r\n    },\r\n    replace: true,\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n      if (!ngModelCtrl) {\r\n        return; // do nothing if no ng-model\r\n      }\r\n\r\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging'])\r\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\r\n  var ctrl = this;\r\n  // Setup configuration parameters\r\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\r\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\r\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\r\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\r\n    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\r\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\r\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\r\n\r\n  uibPaging.create(this, $scope, $attrs);\r\n\r\n  if ($attrs.maxSize) {\r\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\r\n      maxSize = parseInt(value, 10);\r\n      ctrl.render();\r\n    }));\r\n  }\r\n\r\n  // Create page object used in template\r\n  function makePage(number, text, isActive) {\r\n    return {\r\n      number: number,\r\n      text: text,\r\n      active: isActive\r\n    };\r\n  }\r\n\r\n  function getPages(currentPage, totalPages) {\r\n    var pages = [];\r\n\r\n    // Default page limits\r\n    var startPage = 1, endPage = totalPages;\r\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\r\n\r\n    // recompute if maxSize\r\n    if (isMaxSized) {\r\n      if (rotate) {\r\n        // Current page is displayed in the middle of the visible ones\r\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\r\n        endPage = startPage + maxSize - 1;\r\n\r\n        // Adjust if limit is exceeded\r\n        if (endPage > totalPages) {\r\n          endPage = totalPages;\r\n          startPage = endPage - maxSize + 1;\r\n        }\r\n      } else {\r\n        // Visible pages are paginated with maxSize\r\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\r\n\r\n        // Adjust last page if limit is exceeded\r\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\r\n      }\r\n    }\r\n\r\n    // Add page number links\r\n    for (var number = startPage; number <= endPage; number++) {\r\n      var page = makePage(number, pageLabel(number), number === currentPage);\r\n      pages.push(page);\r\n    }\r\n\r\n    // Add links to move between page sets\r\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\r\n      if (startPage > 1) {\r\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\r\n        var previousPageSet = makePage(startPage - 1, '...', false);\r\n        pages.unshift(previousPageSet);\r\n      }\r\n        if (boundaryLinkNumbers) {\r\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\r\n            var secondPageLink = makePage(2, '2', false);\r\n            pages.unshift(secondPageLink);\r\n          }\r\n          //add the first page\r\n          var firstPageLink = makePage(1, '1', false);\r\n          pages.unshift(firstPageLink);\r\n        }\r\n      }\r\n\r\n      if (endPage < totalPages) {\r\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\r\n        var nextPageSet = makePage(endPage + 1, '...', false);\r\n        pages.push(nextPageSet);\r\n      }\r\n        if (boundaryLinkNumbers) {\r\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\r\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\r\n            pages.push(secondToLastPageLink);\r\n          }\r\n          //add the last page\r\n          var lastPageLink = makePage(totalPages, totalPages, false);\r\n          pages.push(lastPageLink);\r\n        }\r\n      }\r\n    }\r\n    return pages;\r\n  }\r\n\r\n  var originalRender = this.render;\r\n  this.render = function() {\r\n    originalRender();\r\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\r\n      $scope.pages = getPages($scope.page, $scope.totalPages);\r\n    }\r\n  };\r\n}])\r\n\r\n.constant('uibPaginationConfig', {\r\n  itemsPerPage: 10,\r\n  boundaryLinks: false,\r\n  boundaryLinkNumbers: false,\r\n  directionLinks: true,\r\n  firstText: 'First',\r\n  previousText: 'Previous',\r\n  nextText: 'Next',\r\n  lastText: 'Last',\r\n  rotate: true,\r\n  forceEllipses: false\r\n})\r\n\r\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\r\n  return {\r\n    scope: {\r\n      totalItems: '=',\r\n      firstText: '@',\r\n      previousText: '@',\r\n      nextText: '@',\r\n      lastText: '@',\r\n      ngDisabled:'='\r\n    },\r\n    require: ['uibPagination', '?ngModel'],\r\n    controller: 'UibPaginationController',\r\n    controllerAs: 'pagination',\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\r\n    },\r\n    replace: true,\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n      if (!ngModelCtrl) {\r\n         return; // do nothing if no ng-model\r\n      }\r\n\r\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\r\n    }\r\n  };\r\n}]);\r\n\r\n/**\r\n * The following features are still outstanding: animation as a\r\n * function, placement as a function, inside, support for more triggers than\r\n * just mouse enter/leave, html tooltips, and selector delegation.\r\n */\r\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\r\n\r\n/**\r\n * The $tooltip service creates tooltip- and popover-like directives as well as\r\n * houses global options for them.\r\n */\r\n.provider('$uibTooltip', function() {\r\n  // The default options tooltip and popover.\r\n  var defaultOptions = {\r\n    placement: 'top',\r\n    placementClassPrefix: '',\r\n    animation: true,\r\n    popupDelay: 0,\r\n    popupCloseDelay: 0,\r\n    useContentExp: false\r\n  };\r\n\r\n  // Default hide triggers for each show trigger\r\n  var triggerMap = {\r\n    'mouseenter': 'mouseleave',\r\n    'click': 'click',\r\n    'outsideClick': 'outsideClick',\r\n    'focus': 'blur',\r\n    'none': ''\r\n  };\r\n\r\n  // The options specified to the provider globally.\r\n  var globalOptions = {};\r\n\r\n  /**\r\n   * `options({})` allows global configuration of all tooltips in the\r\n   * application.\r\n   *\r\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\r\n   *     // place tooltips left instead of top by default\r\n   *     $tooltipProvider.options( { placement: 'left' } );\r\n   *   });\r\n   */\r\n\tthis.options = function(value) {\r\n\t\tangular.extend(globalOptions, value);\r\n\t};\r\n\r\n  /**\r\n   * This allows you to extend the set of trigger mappings available. E.g.:\r\n   *\r\n   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );\r\n   */\r\n  this.setTriggers = function setTriggers(triggers) {\r\n    angular.extend(triggerMap, triggers);\r\n  };\r\n\r\n  /**\r\n   * This is a helper function for translating camel-case to snake_case.\r\n   */\r\n  function snake_case(name) {\r\n    var regexp = /[A-Z]/g;\r\n    var separator = '-';\r\n    return name.replace(regexp, function(letter, pos) {\r\n      return (pos ? separator : '') + letter.toLowerCase();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the actual instance of the $tooltip service.\r\n   * TODO support multiple triggers\r\n   */\r\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\r\n    var openedTooltips = $$stackedMap.createNew();\r\n    $document.on('keypress', keypressListener);\r\n\r\n    $rootScope.$on('$destroy', function() {\r\n      $document.off('keypress', keypressListener);\r\n    });\r\n\r\n    function keypressListener(e) {\r\n      if (e.which === 27) {\r\n        var last = openedTooltips.top();\r\n        if (last) {\r\n          last.value.close();\r\n          openedTooltips.removeTop();\r\n          last = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\r\n      options = angular.extend({}, defaultOptions, globalOptions, options);\r\n\r\n      /**\r\n       * Returns an object of show and hide triggers.\r\n       *\r\n       * If a trigger is supplied,\r\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\r\n       * option passed to the `$tooltipProvider.options` method; else it will\r\n       * default to the trigger supplied to this directive factory.\r\n       *\r\n       * The hide trigger is based on the show trigger. If the `trigger` option\r\n       * was passed to the `$tooltipProvider.options` method, it will use the\r\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\r\n       * undefined; otherwise, it uses the `triggerMap` value of the show\r\n       * trigger; else it will just use the show trigger.\r\n       */\r\n      function getTriggers(trigger) {\r\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\r\n        var hide = show.map(function(trigger) {\r\n          return triggerMap[trigger] || trigger;\r\n        });\r\n        return {\r\n          show: show,\r\n          hide: hide\r\n        };\r\n      }\r\n\r\n      var directiveName = snake_case(ttType);\r\n\r\n      var startSym = $interpolate.startSymbol();\r\n      var endSym = $interpolate.endSymbol();\r\n      var template =\r\n        '<div '+ directiveName + '-popup ' +\r\n          'uib-title=\"' + startSym + 'title' + endSym + '\" ' +\r\n          (options.useContentExp ?\r\n            'content-exp=\"contentExp()\" ' :\r\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\r\n          'placement=\"' + startSym + 'placement' + endSym + '\" ' +\r\n          'popup-class=\"' + startSym + 'popupClass' + endSym + '\" ' +\r\n          'animation=\"animation\" ' +\r\n          'is-open=\"isOpen\" ' +\r\n          'origin-scope=\"origScope\" ' +\r\n          'class=\"uib-position-measure\"' +\r\n          '>' +\r\n        '</div>';\r\n\r\n      return {\r\n        compile: function(tElem, tAttrs) {\r\n          var tooltipLinker = $compile(template);\r\n\r\n          return function link(scope, element, attrs, tooltipCtrl) {\r\n            var tooltip;\r\n            var tooltipLinkedScope;\r\n            var transitionTimeout;\r\n            var showTimeout;\r\n            var hideTimeout;\r\n            var positionTimeout;\r\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\r\n            var triggers = getTriggers(undefined);\r\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\r\n            var ttScope = scope.$new(true);\r\n            var repositionScheduled = false;\r\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\r\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\r\n            var observers = [];\r\n            var lastPlacement;\r\n\r\n            var positionTooltip = function() {\r\n              // check if tooltip exists and is not empty\r\n              if (!tooltip || !tooltip.html()) { return; }\r\n\r\n              if (!positionTimeout) {\r\n                positionTimeout = $timeout(function() {\r\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\r\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\r\n\r\n                  if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {\r\n                    tooltip.removeClass(lastPlacement.split('-')[0]);\r\n                    tooltip.addClass(ttPosition.placement.split('-')[0]);\r\n                  }\r\n\r\n                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\r\n                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\r\n                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\r\n                  }\r\n\r\n                  // first time through tt element will have the\r\n                  // uib-position-measure class or if the placement\r\n                  // has changed we need to position the arrow.\r\n                  if (tooltip.hasClass('uib-position-measure')) {\r\n                    $position.positionArrow(tooltip, ttPosition.placement);\r\n                    tooltip.removeClass('uib-position-measure');\r\n                  } else if (lastPlacement !== ttPosition.placement) {\r\n                    $position.positionArrow(tooltip, ttPosition.placement);\r\n                  }\r\n                  lastPlacement = ttPosition.placement;\r\n\r\n                  positionTimeout = null;\r\n                }, 0, false);\r\n              }\r\n            };\r\n\r\n            // Set up the correct scope to allow transclusion later\r\n            ttScope.origScope = scope;\r\n\r\n            // By default, the tooltip is not open.\r\n            // TODO add ability to start tooltip opened\r\n            ttScope.isOpen = false;\r\n            openedTooltips.add(ttScope, {\r\n              close: hide\r\n            });\r\n\r\n            function toggleTooltipBind() {\r\n              if (!ttScope.isOpen) {\r\n                showTooltipBind();\r\n              } else {\r\n                hideTooltipBind();\r\n              }\r\n            }\r\n\r\n            // Show the tooltip with delay if specified, otherwise show it immediately\r\n            function showTooltipBind() {\r\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\r\n                return;\r\n              }\r\n\r\n              cancelHide();\r\n              prepareTooltip();\r\n\r\n              if (ttScope.popupDelay) {\r\n                // Do nothing if the tooltip was already scheduled to pop-up.\r\n                // This happens if show is triggered multiple times before any hide is triggered.\r\n                if (!showTimeout) {\r\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\r\n                }\r\n              } else {\r\n                show();\r\n              }\r\n            }\r\n\r\n            function hideTooltipBind() {\r\n              cancelShow();\r\n\r\n              if (ttScope.popupCloseDelay) {\r\n                if (!hideTimeout) {\r\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\r\n                }\r\n              } else {\r\n                hide();\r\n              }\r\n            }\r\n\r\n            // Show the tooltip popup element.\r\n            function show() {\r\n              cancelShow();\r\n              cancelHide();\r\n\r\n              // Don't show empty tooltips.\r\n              if (!ttScope.content) {\r\n                return angular.noop;\r\n              }\r\n\r\n              createTooltip();\r\n\r\n              // And show the tooltip.\r\n              ttScope.$evalAsync(function() {\r\n                ttScope.isOpen = true;\r\n                assignIsOpen(true);\r\n                positionTooltip();\r\n              });\r\n            }\r\n\r\n            function cancelShow() {\r\n              if (showTimeout) {\r\n                $timeout.cancel(showTimeout);\r\n                showTimeout = null;\r\n              }\r\n\r\n              if (positionTimeout) {\r\n                $timeout.cancel(positionTimeout);\r\n                positionTimeout = null;\r\n              }\r\n            }\r\n\r\n            // Hide the tooltip popup element.\r\n            function hide() {\r\n              if (!ttScope) {\r\n                return;\r\n              }\r\n\r\n              // First things first: we don't show it anymore.\r\n              ttScope.$evalAsync(function() {\r\n                if (ttScope) {\r\n                  ttScope.isOpen = false;\r\n                  assignIsOpen(false);\r\n                  // And now we remove it from the DOM. However, if we have animation, we\r\n                  // need to wait for it to expire beforehand.\r\n                  // FIXME: this is a placeholder for a port of the transitions library.\r\n                  // The fade transition in TWBS is 150ms.\r\n                  if (ttScope.animation) {\r\n                    if (!transitionTimeout) {\r\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\r\n                    }\r\n                  } else {\r\n                    removeTooltip();\r\n                  }\r\n                }\r\n              });\r\n            }\r\n\r\n            function cancelHide() {\r\n              if (hideTimeout) {\r\n                $timeout.cancel(hideTimeout);\r\n                hideTimeout = null;\r\n              }\r\n\r\n              if (transitionTimeout) {\r\n                $timeout.cancel(transitionTimeout);\r\n                transitionTimeout = null;\r\n              }\r\n            }\r\n\r\n            function createTooltip() {\r\n              // There can only be one tooltip element per directive shown at once.\r\n              if (tooltip) {\r\n                return;\r\n              }\r\n\r\n              tooltipLinkedScope = ttScope.$new();\r\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\r\n                if (appendToBody) {\r\n                  $document.find('body').append(tooltip);\r\n                } else {\r\n                  element.after(tooltip);\r\n                }\r\n              });\r\n\r\n              prepObservers();\r\n            }\r\n\r\n            function removeTooltip() {\r\n              cancelShow();\r\n              cancelHide();\r\n              unregisterObservers();\r\n\r\n              if (tooltip) {\r\n                tooltip.remove();\r\n                tooltip = null;\r\n              }\r\n              if (tooltipLinkedScope) {\r\n                tooltipLinkedScope.$destroy();\r\n                tooltipLinkedScope = null;\r\n              }\r\n            }\r\n\r\n            /**\r\n             * Set the initial scope values. Once\r\n             * the tooltip is created, the observers\r\n             * will be added to keep things in sync.\r\n             */\r\n            function prepareTooltip() {\r\n              ttScope.title = attrs[prefix + 'Title'];\r\n              if (contentParse) {\r\n                ttScope.content = contentParse(scope);\r\n              } else {\r\n                ttScope.content = attrs[ttType];\r\n              }\r\n\r\n              ttScope.popupClass = attrs[prefix + 'Class'];\r\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\r\n              var placement = $position.parsePlacement(ttScope.placement);\r\n              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\r\n\r\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\r\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\r\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\r\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\r\n            }\r\n\r\n            function assignIsOpen(isOpen) {\r\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\r\n                isOpenParse.assign(scope, isOpen);\r\n              }\r\n            }\r\n\r\n            ttScope.contentExp = function() {\r\n              return ttScope.content;\r\n            };\r\n\r\n            /**\r\n             * Observe the relevant attributes.\r\n             */\r\n            attrs.$observe('disabled', function(val) {\r\n              if (val) {\r\n                cancelShow();\r\n              }\r\n\r\n              if (val && ttScope.isOpen) {\r\n                hide();\r\n              }\r\n            });\r\n\r\n            if (isOpenParse) {\r\n              scope.$watch(isOpenParse, function(val) {\r\n                if (ttScope && !val === ttScope.isOpen) {\r\n                  toggleTooltipBind();\r\n                }\r\n              });\r\n            }\r\n\r\n            function prepObservers() {\r\n              observers.length = 0;\r\n\r\n              if (contentParse) {\r\n                observers.push(\r\n                  scope.$watch(contentParse, function(val) {\r\n                    ttScope.content = val;\r\n                    if (!val && ttScope.isOpen) {\r\n                      hide();\r\n                    }\r\n                  })\r\n                );\r\n\r\n                observers.push(\r\n                  tooltipLinkedScope.$watch(function() {\r\n                    if (!repositionScheduled) {\r\n                      repositionScheduled = true;\r\n                      tooltipLinkedScope.$$postDigest(function() {\r\n                        repositionScheduled = false;\r\n                        if (ttScope && ttScope.isOpen) {\r\n                          positionTooltip();\r\n                        }\r\n                      });\r\n                    }\r\n                  })\r\n                );\r\n              } else {\r\n                observers.push(\r\n                  attrs.$observe(ttType, function(val) {\r\n                    ttScope.content = val;\r\n                    if (!val && ttScope.isOpen) {\r\n                      hide();\r\n                    } else {\r\n                      positionTooltip();\r\n                    }\r\n                  })\r\n                );\r\n              }\r\n\r\n              observers.push(\r\n                attrs.$observe(prefix + 'Title', function(val) {\r\n                  ttScope.title = val;\r\n                  if (ttScope.isOpen) {\r\n                    positionTooltip();\r\n                  }\r\n                })\r\n              );\r\n\r\n              observers.push(\r\n                attrs.$observe(prefix + 'Placement', function(val) {\r\n                  ttScope.placement = val ? val : options.placement;\r\n                  if (ttScope.isOpen) {\r\n                    positionTooltip();\r\n                  }\r\n                })\r\n              );\r\n            }\r\n\r\n            function unregisterObservers() {\r\n              if (observers.length) {\r\n                angular.forEach(observers, function(observer) {\r\n                  observer();\r\n                });\r\n                observers.length = 0;\r\n              }\r\n            }\r\n\r\n            // hide tooltips/popovers for outsideClick trigger\r\n            function bodyHideTooltipBind(e) {\r\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\r\n                return;\r\n              }\r\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\r\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\r\n                hideTooltipBind();\r\n              }\r\n            }\r\n\r\n            var unregisterTriggers = function() {\r\n              triggers.show.forEach(function(trigger) {\r\n                if (trigger === 'outsideClick') {\r\n                  element.off('click', toggleTooltipBind);\r\n                } else {\r\n                  element.off(trigger, showTooltipBind);\r\n                  element.off(trigger, toggleTooltipBind);\r\n                }\r\n              });\r\n              triggers.hide.forEach(function(trigger) {\r\n                if (trigger === 'outsideClick') {\r\n                  $document.off('click', bodyHideTooltipBind);\r\n                } else {\r\n                  element.off(trigger, hideTooltipBind);\r\n                }\r\n              });\r\n            };\r\n\r\n            function prepTriggers() {\r\n              var val = attrs[prefix + 'Trigger'];\r\n              unregisterTriggers();\r\n\r\n              triggers = getTriggers(val);\r\n\r\n              if (triggers.show !== 'none') {\r\n                triggers.show.forEach(function(trigger, idx) {\r\n                  if (trigger === 'outsideClick') {\r\n                    element.on('click', toggleTooltipBind);\r\n                    $document.on('click', bodyHideTooltipBind);\r\n                  } else if (trigger === triggers.hide[idx]) {\r\n                    element.on(trigger, toggleTooltipBind);\r\n                  } else if (trigger) {\r\n                    element.on(trigger, showTooltipBind);\r\n                    element.on(triggers.hide[idx], hideTooltipBind);\r\n                  }\r\n\r\n                  element.on('keypress', function(e) {\r\n                    if (e.which === 27) {\r\n                      hideTooltipBind();\r\n                    }\r\n                  });\r\n                });\r\n              }\r\n            }\r\n\r\n            prepTriggers();\r\n\r\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\r\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\r\n\r\n            var appendToBodyVal;\r\n            var appendKey = prefix + 'AppendToBody';\r\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\r\n              appendToBodyVal = true;\r\n            } else {\r\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\r\n            }\r\n\r\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\r\n\r\n            // Make sure tooltip is destroyed and removed.\r\n            scope.$on('$destroy', function onDestroyTooltip() {\r\n              unregisterTriggers();\r\n              removeTooltip();\r\n              openedTooltips.remove(ttScope);\r\n              ttScope = null;\r\n            });\r\n          };\r\n        }\r\n      };\r\n    };\r\n  }];\r\n})\r\n\r\n// This is mostly ngInclude code but with a custom scope\r\n.directive('uibTooltipTemplateTransclude', [\r\n         '$animate', '$sce', '$compile', '$templateRequest',\r\nfunction ($animate, $sce, $compile, $templateRequest) {\r\n  return {\r\n    link: function(scope, elem, attrs) {\r\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\r\n\r\n      var changeCounter = 0,\r\n        currentScope,\r\n        previousElement,\r\n        currentElement;\r\n\r\n      var cleanupLastIncludeContent = function() {\r\n        if (previousElement) {\r\n          previousElement.remove();\r\n          previousElement = null;\r\n        }\r\n\r\n        if (currentScope) {\r\n          currentScope.$destroy();\r\n          currentScope = null;\r\n        }\r\n\r\n        if (currentElement) {\r\n          $animate.leave(currentElement).then(function() {\r\n            previousElement = null;\r\n          });\r\n          previousElement = currentElement;\r\n          currentElement = null;\r\n        }\r\n      };\r\n\r\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\r\n        var thisChangeId = ++changeCounter;\r\n\r\n        if (src) {\r\n          //set the 2nd param to true to ignore the template request error so that the inner\r\n          //contents and scope can be cleaned up.\r\n          $templateRequest(src, true).then(function(response) {\r\n            if (thisChangeId !== changeCounter) { return; }\r\n            var newScope = origScope.$new();\r\n            var template = response;\r\n\r\n            var clone = $compile(template)(newScope, function(clone) {\r\n              cleanupLastIncludeContent();\r\n              $animate.enter(clone, elem);\r\n            });\r\n\r\n            currentScope = newScope;\r\n            currentElement = clone;\r\n\r\n            currentScope.$emit('$includeContentLoaded', src);\r\n          }, function() {\r\n            if (thisChangeId === changeCounter) {\r\n              cleanupLastIncludeContent();\r\n              scope.$emit('$includeContentError', src);\r\n            }\r\n          });\r\n          scope.$emit('$includeContentRequested', src);\r\n        } else {\r\n          cleanupLastIncludeContent();\r\n        }\r\n      });\r\n\r\n      scope.$on('$destroy', cleanupLastIncludeContent);\r\n    }\r\n  };\r\n}])\r\n\r\n/**\r\n * Note that it's intentional that these classes are *not* applied through $animate.\r\n * They must not be animated as they're expected to be present on the tooltip on\r\n * initialization.\r\n */\r\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\r\n  return {\r\n    restrict: 'A',\r\n    link: function(scope, element, attrs) {\r\n      // need to set the primary position so the\r\n      // arrow has space during position measure.\r\n      // tooltip.positionTooltip()\r\n      if (scope.placement) {\r\n        // // There are no top-left etc... classes\r\n        // // in TWBS, so we need the primary position.\r\n        var position = $uibPosition.parsePlacement(scope.placement);\r\n        element.addClass(position[0]);\r\n      }\r\n\r\n      if (scope.popupClass) {\r\n        element.addClass(scope.popupClass);\r\n      }\r\n\r\n      if (scope.animation()) {\r\n        element.addClass(attrs.tooltipAnimationClass);\r\n      }\r\n    }\r\n  };\r\n}])\r\n\r\n.directive('uibTooltipPopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\r\n  };\r\n})\r\n\r\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\r\n}])\r\n\r\n.directive('uibTooltipTemplatePopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\r\n      originScope: '&' },\r\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\r\n  };\r\n})\r\n\r\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\r\n    useContentExp: true\r\n  });\r\n}])\r\n\r\n.directive('uibTooltipHtmlPopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\r\n  };\r\n})\r\n\r\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\r\n    useContentExp: true\r\n  });\r\n}]);\r\n\r\n/**\r\n * The following features are still outstanding: popup delay, animation as a\r\n * function, placement as a function, inside, support for more triggers than\r\n * just mouse enter/leave, and selector delegatation.\r\n */\r\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\r\n\r\n.directive('uibPopoverTemplatePopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { uibTitle: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',\r\n      originScope: '&' },\r\n    templateUrl: 'uib/template/popover/popover-template.html'\r\n  };\r\n})\r\n\r\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\r\n    useContentExp: true\r\n  });\r\n}])\r\n\r\n.directive('uibPopoverHtmlPopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { contentExp: '&', uibTitle: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'uib/template/popover/popover-html.html'\r\n  };\r\n})\r\n\r\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\r\n    useContentExp: true\r\n  });\r\n}])\r\n\r\n.directive('uibPopoverPopup', function() {\r\n  return {\r\n    replace: true,\r\n    scope: { uibTitle: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },\r\n    templateUrl: 'uib/template/popover/popover.html'\r\n  };\r\n})\r\n\r\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\r\n  return $uibTooltip('uibPopover', 'popover', 'click');\r\n}]);\r\n\r\nangular.module('ui.bootstrap.progressbar', [])\r\n\r\n.constant('uibProgressConfig', {\r\n  animate: true,\r\n  max: 100\r\n})\r\n\r\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\r\n  var self = this,\r\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\r\n\r\n  this.bars = [];\r\n  $scope.max = getMaxOrDefault();\r\n\r\n  this.addBar = function(bar, element, attrs) {\r\n    if (!animate) {\r\n      element.css({'transition': 'none'});\r\n    }\r\n\r\n    this.bars.push(bar);\r\n\r\n    bar.max = getMaxOrDefault();\r\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\r\n\r\n    bar.$watch('value', function(value) {\r\n      bar.recalculatePercentage();\r\n    });\r\n\r\n    bar.recalculatePercentage = function() {\r\n      var totalPercentage = self.bars.reduce(function(total, bar) {\r\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\r\n        return total + bar.percent;\r\n      }, 0);\r\n\r\n      if (totalPercentage > 100) {\r\n        bar.percent -= totalPercentage - 100;\r\n      }\r\n    };\r\n\r\n    bar.$on('$destroy', function() {\r\n      element = null;\r\n      self.removeBar(bar);\r\n    });\r\n  };\r\n\r\n  this.removeBar = function(bar) {\r\n    this.bars.splice(this.bars.indexOf(bar), 1);\r\n    this.bars.forEach(function (bar) {\r\n      bar.recalculatePercentage();\r\n    });\r\n  };\r\n\r\n  //$attrs.$observe('maxParam', function(maxParam) {\r\n  $scope.$watch('maxParam', function(maxParam) {\r\n    self.bars.forEach(function(bar) {\r\n      bar.max = getMaxOrDefault();\r\n      bar.recalculatePercentage();\r\n    });\r\n  });\r\n\r\n  function getMaxOrDefault () {\r\n    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\r\n  }\r\n}])\r\n\r\n.directive('uibProgress', function() {\r\n  return {\r\n    replace: true,\r\n    transclude: true,\r\n    controller: 'UibProgressController',\r\n    require: 'uibProgress',\r\n    scope: {\r\n      maxParam: '=?max'\r\n    },\r\n    templateUrl: 'uib/template/progressbar/progress.html'\r\n  };\r\n})\r\n\r\n.directive('uibBar', function() {\r\n  return {\r\n    replace: true,\r\n    transclude: true,\r\n    require: '^uibProgress',\r\n    scope: {\r\n      value: '=',\r\n      type: '@'\r\n    },\r\n    templateUrl: 'uib/template/progressbar/bar.html',\r\n    link: function(scope, element, attrs, progressCtrl) {\r\n      progressCtrl.addBar(scope, element, attrs);\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibProgressbar', function() {\r\n  return {\r\n    replace: true,\r\n    transclude: true,\r\n    controller: 'UibProgressController',\r\n    scope: {\r\n      value: '=',\r\n      maxParam: '=?max',\r\n      type: '@'\r\n    },\r\n    templateUrl: 'uib/template/progressbar/progressbar.html',\r\n    link: function(scope, element, attrs, progressCtrl) {\r\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.rating', [])\r\n\r\n.constant('uibRatingConfig', {\r\n  max: 5,\r\n  stateOn: null,\r\n  stateOff: null,\r\n  enableReset: true,\r\n  titles : ['one', 'two', 'three', 'four', 'five']\r\n})\r\n\r\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\r\n  var ngModelCtrl = { $setViewValue: angular.noop },\r\n    self = this;\r\n\r\n  this.init = function(ngModelCtrl_) {\r\n    ngModelCtrl = ngModelCtrl_;\r\n    ngModelCtrl.$render = this.render;\r\n\r\n    ngModelCtrl.$formatters.push(function(value) {\r\n      if (angular.isNumber(value) && value << 0 !== value) {\r\n        value = Math.round(value);\r\n      }\r\n\r\n      return value;\r\n    });\r\n\r\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\r\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\r\n    this.enableReset = angular.isDefined($attrs.enableReset) ?\r\n      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;\r\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;\r\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\r\n      tmpTitles : ratingConfig.titles;\r\n\r\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\r\n      $scope.$parent.$eval($attrs.ratingStates) :\r\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\r\n    $scope.range = this.buildTemplateObjects(ratingStates);\r\n  };\r\n\r\n  this.buildTemplateObjects = function(states) {\r\n    for (var i = 0, n = states.length; i < n; i++) {\r\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\r\n    }\r\n    return states;\r\n  };\r\n\r\n  this.getTitle = function(index) {\r\n    if (index >= this.titles.length) {\r\n      return index + 1;\r\n    }\r\n\r\n    return this.titles[index];\r\n  };\r\n\r\n  $scope.rate = function(value) {\r\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\r\n      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;\r\n      ngModelCtrl.$setViewValue(newViewValue);\r\n      ngModelCtrl.$render();\r\n    }\r\n  };\r\n\r\n  $scope.enter = function(value) {\r\n    if (!$scope.readonly) {\r\n      $scope.value = value;\r\n    }\r\n    $scope.onHover({value: value});\r\n  };\r\n\r\n  $scope.reset = function() {\r\n    $scope.value = ngModelCtrl.$viewValue;\r\n    $scope.onLeave();\r\n  };\r\n\r\n  $scope.onKeydown = function(evt) {\r\n    if (/(37|38|39|40)/.test(evt.which)) {\r\n      evt.preventDefault();\r\n      evt.stopPropagation();\r\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\r\n    }\r\n  };\r\n\r\n  this.render = function() {\r\n    $scope.value = ngModelCtrl.$viewValue;\r\n    $scope.title = self.getTitle($scope.value - 1);\r\n  };\r\n}])\r\n\r\n.directive('uibRating', function() {\r\n  return {\r\n    require: ['uibRating', 'ngModel'],\r\n    scope: {\r\n      readonly: '=?readOnly',\r\n      onHover: '&',\r\n      onLeave: '&'\r\n    },\r\n    controller: 'UibRatingController',\r\n    templateUrl: 'uib/template/rating/rating.html',\r\n    replace: true,\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n      ratingCtrl.init(ngModelCtrl);\r\n    }\r\n  };\r\n});\r\n\r\nangular.module('ui.bootstrap.tabs', [])\r\n\r\n.controller('UibTabsetController', ['$scope', function ($scope) {\r\n  var ctrl = this,\r\n    oldIndex;\r\n  ctrl.tabs = [];\r\n\r\n  ctrl.select = function(index, evt) {\r\n    if (!destroyed) {\r\n      var previousIndex = findTabIndex(oldIndex);\r\n      var previousSelected = ctrl.tabs[previousIndex];\r\n      if (previousSelected) {\r\n        previousSelected.tab.onDeselect({\r\n          $event: evt,\r\n          $selectedIndex: index\r\n        });\r\n        if (evt && evt.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        previousSelected.tab.active = false;\r\n      }\r\n\r\n      var selected = ctrl.tabs[index];\r\n      if (selected) {\r\n        selected.tab.onSelect({\r\n          $event: evt\r\n        });\r\n        selected.tab.active = true;\r\n        ctrl.active = selected.index;\r\n        oldIndex = selected.index;\r\n      } else if (!selected && angular.isDefined(oldIndex)) {\r\n        ctrl.active = null;\r\n        oldIndex = null;\r\n      }\r\n    }\r\n  };\r\n\r\n  ctrl.addTab = function addTab(tab) {\r\n    ctrl.tabs.push({\r\n      tab: tab,\r\n      index: tab.index\r\n    });\r\n    ctrl.tabs.sort(function(t1, t2) {\r\n      if (t1.index > t2.index) {\r\n        return 1;\r\n      }\r\n\r\n      if (t1.index < t2.index) {\r\n        return -1;\r\n      }\r\n\r\n      return 0;\r\n    });\r\n\r\n    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {\r\n      var newActiveIndex = findTabIndex(tab.index);\r\n      ctrl.select(newActiveIndex);\r\n    }\r\n  };\r\n\r\n  ctrl.removeTab = function removeTab(tab) {\r\n    var index;\r\n    for (var i = 0; i < ctrl.tabs.length; i++) {\r\n      if (ctrl.tabs[i].tab === tab) {\r\n        index = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (ctrl.tabs[index].index === ctrl.active) {\r\n      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\r\n        index - 1 : index + 1 % ctrl.tabs.length;\r\n      ctrl.select(newActiveTabIndex);\r\n    }\r\n\r\n    ctrl.tabs.splice(index, 1);\r\n  };\r\n\r\n  $scope.$watch('tabset.active', function(val) {\r\n    if (angular.isDefined(val) && val !== oldIndex) {\r\n      ctrl.select(findTabIndex(val));\r\n    }\r\n  });\r\n\r\n  var destroyed;\r\n  $scope.$on('$destroy', function() {\r\n    destroyed = true;\r\n  });\r\n\r\n  function findTabIndex(index) {\r\n    for (var i = 0; i < ctrl.tabs.length; i++) {\r\n      if (ctrl.tabs[i].index === index) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n}])\r\n\r\n.directive('uibTabset', function() {\r\n  return {\r\n    transclude: true,\r\n    replace: true,\r\n    scope: {},\r\n    bindToController: {\r\n      active: '=?',\r\n      type: '@'\r\n    },\r\n    controller: 'UibTabsetController',\r\n    controllerAs: 'tabset',\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\r\n    },\r\n    link: function(scope, element, attrs) {\r\n      scope.vertical = angular.isDefined(attrs.vertical) ?\r\n        scope.$parent.$eval(attrs.vertical) : false;\r\n      scope.justified = angular.isDefined(attrs.justified) ?\r\n        scope.$parent.$eval(attrs.justified) : false;\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibTab', ['$parse', function($parse) {\r\n  return {\r\n    require: '^uibTabset',\r\n    replace: true,\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || 'uib/template/tabs/tab.html';\r\n    },\r\n    transclude: true,\r\n    scope: {\r\n      heading: '@',\r\n      index: '=?',\r\n      classes: '@?',\r\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\r\n                          //once it inserts the tab's content into the dom\r\n      onDeselect: '&deselect'\r\n    },\r\n    controller: function() {\r\n      //Empty controller so other directives can require being 'under' a tab\r\n    },\r\n    controllerAs: 'tab',\r\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\r\n      scope.disabled = false;\r\n      if (attrs.disable) {\r\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\r\n          scope.disabled = !! value;\r\n        });\r\n      }\r\n\r\n      if (angular.isUndefined(attrs.index)) {\r\n        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\r\n          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\r\n        } else {\r\n          scope.index = 0;\r\n        }\r\n      }\r\n\r\n      if (angular.isUndefined(attrs.classes)) {\r\n        scope.classes = '';\r\n      }\r\n\r\n      scope.select = function(evt) {\r\n        if (!scope.disabled) {\r\n          var index;\r\n          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\r\n            if (tabsetCtrl.tabs[i].tab === scope) {\r\n              index = i;\r\n              break;\r\n            }\r\n          }\r\n\r\n          tabsetCtrl.select(index, evt);\r\n        }\r\n      };\r\n\r\n      tabsetCtrl.addTab(scope);\r\n      scope.$on('$destroy', function() {\r\n        tabsetCtrl.removeTab(scope);\r\n      });\r\n\r\n      //We need to transclude later, once the content container is ready.\r\n      //when this link happens, we're inside a tab heading.\r\n      scope.$transcludeFn = transclude;\r\n    }\r\n  };\r\n}])\r\n\r\n.directive('uibTabHeadingTransclude', function() {\r\n  return {\r\n    restrict: 'A',\r\n    require: '^uibTab',\r\n    link: function(scope, elm) {\r\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\r\n        if (heading) {\r\n          elm.html('');\r\n          elm.append(heading);\r\n        }\r\n      });\r\n    }\r\n  };\r\n})\r\n\r\n.directive('uibTabContentTransclude', function() {\r\n  return {\r\n    restrict: 'A',\r\n    require: '^uibTabset',\r\n    link: function(scope, elm, attrs) {\r\n      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\r\n\r\n      //Now our tab is ready to be transcluded: both the tab heading area\r\n      //and the tab content area are loaded.  Transclude 'em both.\r\n      tab.$transcludeFn(tab.$parent, function(contents) {\r\n        angular.forEach(contents, function(node) {\r\n          if (isTabHeading(node)) {\r\n            //Let tabHeadingTransclude know.\r\n            tab.headingElement = node;\r\n          } else {\r\n            elm.append(node);\r\n          }\r\n        });\r\n      });\r\n    }\r\n  };\r\n\r\n  function isTabHeading(node) {\r\n    return node.tagName && (\r\n      node.hasAttribute('uib-tab-heading') ||\r\n      node.hasAttribute('data-uib-tab-heading') ||\r\n      node.hasAttribute('x-uib-tab-heading') ||\r\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\r\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\r\n      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||\r\n      node.tagName.toLowerCase() === 'uib:tab-heading'\r\n    );\r\n  }\r\n});\r\n\r\nangular.module('ui.bootstrap.timepicker', [])\r\n\r\n.constant('uibTimepickerConfig', {\r\n  hourStep: 1,\r\n  minuteStep: 1,\r\n  secondStep: 1,\r\n  showMeridian: true,\r\n  showSeconds: false,\r\n  meridians: null,\r\n  readonlyInput: false,\r\n  mousewheel: true,\r\n  arrowkeys: true,\r\n  showSpinners: true,\r\n  templateUrl: 'uib/template/timepicker/timepicker.html'\r\n})\r\n\r\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\r\n  var selected = new Date(),\r\n    watchers = [],\r\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\r\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,\r\n    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;\r\n\r\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\r\n  $element.removeAttr('tabindex');\r\n\r\n  this.init = function(ngModelCtrl_, inputs) {\r\n    ngModelCtrl = ngModelCtrl_;\r\n    ngModelCtrl.$render = this.render;\r\n\r\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\r\n      return modelValue ? new Date(modelValue) : null;\r\n    });\r\n\r\n    var hoursInputEl = inputs.eq(0),\r\n        minutesInputEl = inputs.eq(1),\r\n        secondsInputEl = inputs.eq(2);\r\n\r\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\r\n\r\n    if (mousewheel) {\r\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\r\n    }\r\n\r\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\r\n    if (arrowkeys) {\r\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\r\n    }\r\n\r\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\r\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\r\n  };\r\n\r\n  var hourStep = timepickerConfig.hourStep;\r\n  if ($attrs.hourStep) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\r\n      hourStep = +value;\r\n    }));\r\n  }\r\n\r\n  var minuteStep = timepickerConfig.minuteStep;\r\n  if ($attrs.minuteStep) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\r\n      minuteStep = +value;\r\n    }));\r\n  }\r\n\r\n  var min;\r\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\r\n    var dt = new Date(value);\r\n    min = isNaN(dt) ? undefined : dt;\r\n  }));\r\n\r\n  var max;\r\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\r\n    var dt = new Date(value);\r\n    max = isNaN(dt) ? undefined : dt;\r\n  }));\r\n\r\n  var disabled = false;\r\n  if ($attrs.ngDisabled) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\r\n      disabled = value;\r\n    }));\r\n  }\r\n\r\n  $scope.noIncrementHours = function() {\r\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\r\n    return disabled || incrementedSelected > max ||\r\n      incrementedSelected < selected && incrementedSelected < min;\r\n  };\r\n\r\n  $scope.noDecrementHours = function() {\r\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\r\n    return disabled || decrementedSelected < min ||\r\n      decrementedSelected > selected && decrementedSelected > max;\r\n  };\r\n\r\n  $scope.noIncrementMinutes = function() {\r\n    var incrementedSelected = addMinutes(selected, minuteStep);\r\n    return disabled || incrementedSelected > max ||\r\n      incrementedSelected < selected && incrementedSelected < min;\r\n  };\r\n\r\n  $scope.noDecrementMinutes = function() {\r\n    var decrementedSelected = addMinutes(selected, -minuteStep);\r\n    return disabled || decrementedSelected < min ||\r\n      decrementedSelected > selected && decrementedSelected > max;\r\n  };\r\n\r\n  $scope.noIncrementSeconds = function() {\r\n    var incrementedSelected = addSeconds(selected, secondStep);\r\n    return disabled || incrementedSelected > max ||\r\n      incrementedSelected < selected && incrementedSelected < min;\r\n  };\r\n\r\n  $scope.noDecrementSeconds = function() {\r\n    var decrementedSelected = addSeconds(selected, -secondStep);\r\n    return disabled || decrementedSelected < min ||\r\n      decrementedSelected > selected && decrementedSelected > max;\r\n  };\r\n\r\n  $scope.noToggleMeridian = function() {\r\n    if (selected.getHours() < 12) {\r\n      return disabled || addMinutes(selected, 12 * 60) > max;\r\n    }\r\n\r\n    return disabled || addMinutes(selected, -12 * 60) < min;\r\n  };\r\n\r\n  var secondStep = timepickerConfig.secondStep;\r\n  if ($attrs.secondStep) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\r\n      secondStep = +value;\r\n    }));\r\n  }\r\n\r\n  $scope.showSeconds = timepickerConfig.showSeconds;\r\n  if ($attrs.showSeconds) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\r\n      $scope.showSeconds = !!value;\r\n    }));\r\n  }\r\n\r\n  // 12H / 24H mode\r\n  $scope.showMeridian = timepickerConfig.showMeridian;\r\n  if ($attrs.showMeridian) {\r\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\r\n      $scope.showMeridian = !!value;\r\n\r\n      if (ngModelCtrl.$error.time) {\r\n        // Evaluate from template\r\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\r\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\r\n          selected.setHours(hours);\r\n          refresh();\r\n        }\r\n      } else {\r\n        updateTemplate();\r\n      }\r\n    }));\r\n  }\r\n\r\n  // Get $scope.hours in 24H mode if valid\r\n  function getHoursFromTemplate() {\r\n    var hours = +$scope.hours;\r\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\r\n      hours >= 0 && hours < 24;\r\n    if (!valid || $scope.hours === '') {\r\n      return undefined;\r\n    }\r\n\r\n    if ($scope.showMeridian) {\r\n      if (hours === 12) {\r\n        hours = 0;\r\n      }\r\n      if ($scope.meridian === meridians[1]) {\r\n        hours = hours + 12;\r\n      }\r\n    }\r\n    return hours;\r\n  }\r\n\r\n  function getMinutesFromTemplate() {\r\n    var minutes = +$scope.minutes;\r\n    var valid = minutes >= 0 && minutes < 60;\r\n    if (!valid || $scope.minutes === '') {\r\n      return undefined;\r\n    }\r\n    return minutes;\r\n  }\r\n\r\n  function getSecondsFromTemplate() {\r\n    var seconds = +$scope.seconds;\r\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\r\n  }\r\n\r\n  function pad(value, noPad) {\r\n    if (value === null) {\r\n      return '';\r\n    }\r\n\r\n    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?\r\n      '0' + value : value.toString();\r\n  }\r\n\r\n  // Respond on mousewheel spin\r\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\r\n    var isScrollingUp = function(e) {\r\n      if (e.originalEvent) {\r\n        e = e.originalEvent;\r\n      }\r\n      //pick correct delta variable depending on event\r\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\r\n      return e.detail || delta > 0;\r\n    };\r\n\r\n    hoursInputEl.bind('mousewheel wheel', function(e) {\r\n      if (!disabled) {\r\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\r\n      }\r\n      e.preventDefault();\r\n    });\r\n\r\n    minutesInputEl.bind('mousewheel wheel', function(e) {\r\n      if (!disabled) {\r\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\r\n      }\r\n      e.preventDefault();\r\n    });\r\n\r\n     secondsInputEl.bind('mousewheel wheel', function(e) {\r\n      if (!disabled) {\r\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\r\n      }\r\n      e.preventDefault();\r\n    });\r\n  };\r\n\r\n  // Respond on up/down arrowkeys\r\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\r\n    hoursInputEl.bind('keydown', function(e) {\r\n      if (!disabled) {\r\n        if (e.which === 38) { // up\r\n          e.preventDefault();\r\n          $scope.incrementHours();\r\n          $scope.$apply();\r\n        } else if (e.which === 40) { // down\r\n          e.preventDefault();\r\n          $scope.decrementHours();\r\n          $scope.$apply();\r\n        }\r\n      }\r\n    });\r\n\r\n    minutesInputEl.bind('keydown', function(e) {\r\n      if (!disabled) {\r\n        if (e.which === 38) { // up\r\n          e.preventDefault();\r\n          $scope.incrementMinutes();\r\n          $scope.$apply();\r\n        } else if (e.which === 40) { // down\r\n          e.preventDefault();\r\n          $scope.decrementMinutes();\r\n          $scope.$apply();\r\n        }\r\n      }\r\n    });\r\n\r\n    secondsInputEl.bind('keydown', function(e) {\r\n      if (!disabled) {\r\n        if (e.which === 38) { // up\r\n          e.preventDefault();\r\n          $scope.incrementSeconds();\r\n          $scope.$apply();\r\n        } else if (e.which === 40) { // down\r\n          e.preventDefault();\r\n          $scope.decrementSeconds();\r\n          $scope.$apply();\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\r\n    if ($scope.readonlyInput) {\r\n      $scope.updateHours = angular.noop;\r\n      $scope.updateMinutes = angular.noop;\r\n      $scope.updateSeconds = angular.noop;\r\n      return;\r\n    }\r\n\r\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\r\n      ngModelCtrl.$setViewValue(null);\r\n      ngModelCtrl.$setValidity('time', false);\r\n      if (angular.isDefined(invalidHours)) {\r\n        $scope.invalidHours = invalidHours;\r\n      }\r\n\r\n      if (angular.isDefined(invalidMinutes)) {\r\n        $scope.invalidMinutes = invalidMinutes;\r\n      }\r\n\r\n      if (angular.isDefined(invalidSeconds)) {\r\n        $scope.invalidSeconds = invalidSeconds;\r\n      }\r\n    };\r\n\r\n    $scope.updateHours = function() {\r\n      var hours = getHoursFromTemplate(),\r\n        minutes = getMinutesFromTemplate();\r\n\r\n      ngModelCtrl.$setDirty();\r\n\r\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\r\n        selected.setHours(hours);\r\n        selected.setMinutes(minutes);\r\n        if (selected < min || selected > max) {\r\n          invalidate(true);\r\n        } else {\r\n          refresh('h');\r\n        }\r\n      } else {\r\n        invalidate(true);\r\n      }\r\n    };\r\n\r\n    hoursInputEl.bind('blur', function(e) {\r\n      ngModelCtrl.$setTouched();\r\n      if (modelIsEmpty()) {\r\n        makeValid();\r\n      } else if ($scope.hours === null || $scope.hours === '') {\r\n        invalidate(true);\r\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\r\n        $scope.$apply(function() {\r\n          $scope.hours = pad($scope.hours, !padHours);\r\n        });\r\n      }\r\n    });\r\n\r\n    $scope.updateMinutes = function() {\r\n      var minutes = getMinutesFromTemplate(),\r\n        hours = getHoursFromTemplate();\r\n\r\n      ngModelCtrl.$setDirty();\r\n\r\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\r\n        selected.setHours(hours);\r\n        selected.setMinutes(minutes);\r\n        if (selected < min || selected > max) {\r\n          invalidate(undefined, true);\r\n        } else {\r\n          refresh('m');\r\n        }\r\n      } else {\r\n        invalidate(undefined, true);\r\n      }\r\n    };\r\n\r\n    minutesInputEl.bind('blur', function(e) {\r\n      ngModelCtrl.$setTouched();\r\n      if (modelIsEmpty()) {\r\n        makeValid();\r\n      } else if ($scope.minutes === null) {\r\n        invalidate(undefined, true);\r\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\r\n        $scope.$apply(function() {\r\n          $scope.minutes = pad($scope.minutes);\r\n        });\r\n      }\r\n    });\r\n\r\n    $scope.updateSeconds = function() {\r\n      var seconds = getSecondsFromTemplate();\r\n\r\n      ngModelCtrl.$setDirty();\r\n\r\n      if (angular.isDefined(seconds)) {\r\n        selected.setSeconds(seconds);\r\n        refresh('s');\r\n      } else {\r\n        invalidate(undefined, undefined, true);\r\n      }\r\n    };\r\n\r\n    secondsInputEl.bind('blur', function(e) {\r\n      if (modelIsEmpty()) {\r\n        makeValid();\r\n      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {\r\n        $scope.$apply( function() {\r\n          $scope.seconds = pad($scope.seconds);\r\n        });\r\n      }\r\n    });\r\n\r\n  };\r\n\r\n  this.render = function() {\r\n    var date = ngModelCtrl.$viewValue;\r\n\r\n    if (isNaN(date)) {\r\n      ngModelCtrl.$setValidity('time', false);\r\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\r\n    } else {\r\n      if (date) {\r\n        selected = date;\r\n      }\r\n\r\n      if (selected < min || selected > max) {\r\n        ngModelCtrl.$setValidity('time', false);\r\n        $scope.invalidHours = true;\r\n        $scope.invalidMinutes = true;\r\n      } else {\r\n        makeValid();\r\n      }\r\n      updateTemplate();\r\n    }\r\n  };\r\n\r\n  // Call internally when we know that model is valid.\r\n  function refresh(keyboardChange) {\r\n    makeValid();\r\n    ngModelCtrl.$setViewValue(new Date(selected));\r\n    updateTemplate(keyboardChange);\r\n  }\r\n\r\n  function makeValid() {\r\n    ngModelCtrl.$setValidity('time', true);\r\n    $scope.invalidHours = false;\r\n    $scope.invalidMinutes = false;\r\n    $scope.invalidSeconds = false;\r\n  }\r\n\r\n  function updateTemplate(keyboardChange) {\r\n    if (!ngModelCtrl.$modelValue) {\r\n      $scope.hours = null;\r\n      $scope.minutes = null;\r\n      $scope.seconds = null;\r\n      $scope.meridian = meridians[0];\r\n    } else {\r\n      var hours = selected.getHours(),\r\n        minutes = selected.getMinutes(),\r\n        seconds = selected.getSeconds();\r\n\r\n      if ($scope.showMeridian) {\r\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\r\n      }\r\n\r\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);\r\n      if (keyboardChange !== 'm') {\r\n        $scope.minutes = pad(minutes);\r\n      }\r\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\r\n\r\n      if (keyboardChange !== 's') {\r\n        $scope.seconds = pad(seconds);\r\n      }\r\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\r\n    }\r\n  }\r\n\r\n  function addSecondsToSelected(seconds) {\r\n    selected = addSeconds(selected, seconds);\r\n    refresh();\r\n  }\r\n\r\n  function addMinutes(selected, minutes) {\r\n    return addSeconds(selected, minutes*60);\r\n  }\r\n\r\n  function addSeconds(date, seconds) {\r\n    var dt = new Date(date.getTime() + seconds * 1000);\r\n    var newDate = new Date(date);\r\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\r\n    return newDate;\r\n  }\r\n\r\n  function modelIsEmpty() {\r\n    return ($scope.hours === null || $scope.hours === '') &&\r\n      ($scope.minutes === null || $scope.minutes === '') &&\r\n      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));\r\n  }\r\n\r\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\r\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\r\n\r\n  $scope.incrementHours = function() {\r\n    if (!$scope.noIncrementHours()) {\r\n      addSecondsToSelected(hourStep * 60 * 60);\r\n    }\r\n  };\r\n\r\n  $scope.decrementHours = function() {\r\n    if (!$scope.noDecrementHours()) {\r\n      addSecondsToSelected(-hourStep * 60 * 60);\r\n    }\r\n  };\r\n\r\n  $scope.incrementMinutes = function() {\r\n    if (!$scope.noIncrementMinutes()) {\r\n      addSecondsToSelected(minuteStep * 60);\r\n    }\r\n  };\r\n\r\n  $scope.decrementMinutes = function() {\r\n    if (!$scope.noDecrementMinutes()) {\r\n      addSecondsToSelected(-minuteStep * 60);\r\n    }\r\n  };\r\n\r\n  $scope.incrementSeconds = function() {\r\n    if (!$scope.noIncrementSeconds()) {\r\n      addSecondsToSelected(secondStep);\r\n    }\r\n  };\r\n\r\n  $scope.decrementSeconds = function() {\r\n    if (!$scope.noDecrementSeconds()) {\r\n      addSecondsToSelected(-secondStep);\r\n    }\r\n  };\r\n\r\n  $scope.toggleMeridian = function() {\r\n    var minutes = getMinutesFromTemplate(),\r\n        hours = getHoursFromTemplate();\r\n\r\n    if (!$scope.noToggleMeridian()) {\r\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\r\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\r\n      } else {\r\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\r\n      }\r\n    }\r\n  };\r\n\r\n  $scope.blur = function() {\r\n    ngModelCtrl.$setTouched();\r\n  };\r\n\r\n  $scope.$on('$destroy', function() {\r\n    while (watchers.length) {\r\n      watchers.shift()();\r\n    }\r\n  });\r\n}])\r\n\r\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\r\n  return {\r\n    require: ['uibTimepicker', '?^ngModel'],\r\n    controller: 'UibTimepickerController',\r\n    controllerAs: 'timepicker',\r\n    replace: true,\r\n    scope: {},\r\n    templateUrl: function(element, attrs) {\r\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\r\n    },\r\n    link: function(scope, element, attrs, ctrls) {\r\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n      if (ngModelCtrl) {\r\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\r\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\r\n\r\n/**\r\n * A helper service that can parse typeahead's syntax (string provided by users)\r\n * Extracted to a separate service for ease of unit testing\r\n */\r\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\r\n    //                      00000111000000000000022200000000000000003333333333333330000000000044000\r\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\r\n    return {\r\n      parse: function(input) {\r\n        var match = input.match(TYPEAHEAD_REGEXP);\r\n        if (!match) {\r\n          throw new Error(\r\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\r\n              ' but got \"' + input + '\".');\r\n        }\r\n\r\n        return {\r\n          itemName: match[3],\r\n          source: $parse(match[4]),\r\n          viewMapper: $parse(match[2] || match[1]),\r\n          modelMapper: $parse(match[1])\r\n        };\r\n      }\r\n    };\r\n  }])\r\n\r\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\r\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\r\n    var HOT_KEYS = [9, 13, 27, 38, 40];\r\n    var eventDebounceTime = 200;\r\n    var modelCtrl, ngModelOptions;\r\n    //SUPPORTED ATTRIBUTES (OPTIONS)\r\n\r\n    //minimal no of characters that needs to be entered before typeahead kicks-in\r\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\r\n    if (!minLength && minLength !== 0) {\r\n      minLength = 1;\r\n    }\r\n\r\n    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\r\n        minLength = !newVal && newVal !== 0 ? 1 : newVal;\r\n    });\r\n\r\n    //minimal wait time after last character typed before typeahead kicks-in\r\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\r\n\r\n    //should it restrict model values to the ones selected from the popup only?\r\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\r\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\r\n      isEditable = newVal !== false;\r\n    });\r\n\r\n    //binding to a variable that indicates if matches are being retrieved asynchronously\r\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\r\n\r\n    //a function to determine if an event should cause selection\r\n    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {\r\n      var evt = vals.$event;\r\n      return evt.which === 13 || evt.which === 9;\r\n    };\r\n\r\n    //a callback executed when a match is selected\r\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\r\n\r\n    //should it select highlighted popup value when losing focus?\r\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\r\n\r\n    //binding to a variable that indicates if there were no results after the query is completed\r\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\r\n\r\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\r\n\r\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\r\n\r\n    var appendTo = attrs.typeaheadAppendTo ?\r\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\r\n\r\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\r\n\r\n    //If input matches an item of the list exactly, select it automatically\r\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\r\n\r\n    //binding to a variable that indicates if dropdown is open\r\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\r\n\r\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\r\n\r\n    //INTERNAL VARIABLES\r\n\r\n    //model setter executed upon match selection\r\n    var parsedModel = $parse(attrs.ngModel);\r\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\r\n    var $setModelValue = function(scope, newValue) {\r\n      if (angular.isFunction(parsedModel(originalScope)) &&\r\n        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {\r\n        return invokeModelSetter(scope, {$$$p: newValue});\r\n      }\r\n\r\n      return parsedModel.assign(scope, newValue);\r\n    };\r\n\r\n    //expressions used by typeahead\r\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\r\n\r\n    var hasFocus;\r\n\r\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\r\n    //mousedown & mouseup events\r\n    //Issue #3699\r\n    var selected;\r\n\r\n    //create a child scope for the typeahead directive so we are not polluting original scope\r\n    //with typeahead-specific data (matches, query etc.)\r\n    var scope = originalScope.$new();\r\n    var offDestroy = originalScope.$on('$destroy', function() {\r\n      scope.$destroy();\r\n    });\r\n    scope.$on('$destroy', offDestroy);\r\n\r\n    // WAI-ARIA\r\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\r\n    element.attr({\r\n      'aria-autocomplete': 'list',\r\n      'aria-expanded': false,\r\n      'aria-owns': popupId\r\n    });\r\n\r\n    var inputsContainer, hintInputElem;\r\n    //add read-only input to show hint\r\n    if (showHint) {\r\n      inputsContainer = angular.element('<div></div>');\r\n      inputsContainer.css('position', 'relative');\r\n      element.after(inputsContainer);\r\n      hintInputElem = element.clone();\r\n      hintInputElem.attr('placeholder', '');\r\n      hintInputElem.attr('tabindex', '-1');\r\n      hintInputElem.val('');\r\n      hintInputElem.css({\r\n        'position': 'absolute',\r\n        'top': '0px',\r\n        'left': '0px',\r\n        'border-color': 'transparent',\r\n        'box-shadow': 'none',\r\n        'opacity': 1,\r\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\r\n        'color': '#999'\r\n      });\r\n      element.css({\r\n        'position': 'relative',\r\n        'vertical-align': 'top',\r\n        'background-color': 'transparent'\r\n      });\r\n      inputsContainer.append(hintInputElem);\r\n      hintInputElem.after(element);\r\n    }\r\n\r\n    //pop-up element used to display matches\r\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\r\n    popUpEl.attr({\r\n      id: popupId,\r\n      matches: 'matches',\r\n      active: 'activeIdx',\r\n      select: 'select(activeIdx, evt)',\r\n      'move-in-progress': 'moveInProgress',\r\n      query: 'query',\r\n      position: 'position',\r\n      'assign-is-open': 'assignIsOpen(isOpen)',\r\n      debounce: 'debounceUpdate'\r\n    });\r\n    //custom item template\r\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\r\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\r\n    }\r\n\r\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\r\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\r\n    }\r\n\r\n    var resetHint = function() {\r\n      if (showHint) {\r\n        hintInputElem.val('');\r\n      }\r\n    };\r\n\r\n    var resetMatches = function() {\r\n      scope.matches = [];\r\n      scope.activeIdx = -1;\r\n      element.attr('aria-expanded', false);\r\n      resetHint();\r\n    };\r\n\r\n    var getMatchId = function(index) {\r\n      return popupId + '-option-' + index;\r\n    };\r\n\r\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\r\n    // This attribute is added or removed automatically when the `activeIdx` changes.\r\n    scope.$watch('activeIdx', function(index) {\r\n      if (index < 0) {\r\n        element.removeAttr('aria-activedescendant');\r\n      } else {\r\n        element.attr('aria-activedescendant', getMatchId(index));\r\n      }\r\n    });\r\n\r\n    var inputIsExactMatch = function(inputValue, index) {\r\n      if (scope.matches.length > index && inputValue) {\r\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    var getMatchesAsync = function(inputValue, evt) {\r\n      var locals = {$viewValue: inputValue};\r\n      isLoadingSetter(originalScope, true);\r\n      isNoResultsSetter(originalScope, false);\r\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\r\n        //it might happen that several async queries were in progress if a user were typing fast\r\n        //but we are interested only in responses that correspond to the current view value\r\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\r\n        if (onCurrentRequest && hasFocus) {\r\n          if (matches && matches.length > 0) {\r\n            scope.activeIdx = focusFirst ? 0 : -1;\r\n            isNoResultsSetter(originalScope, false);\r\n            scope.matches.length = 0;\r\n\r\n            //transform labels\r\n            for (var i = 0; i < matches.length; i++) {\r\n              locals[parserResult.itemName] = matches[i];\r\n              scope.matches.push({\r\n                id: getMatchId(i),\r\n                label: parserResult.viewMapper(scope, locals),\r\n                model: matches[i]\r\n              });\r\n            }\r\n\r\n            scope.query = inputValue;\r\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\r\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\r\n            //due to other elements being rendered\r\n            recalculatePosition();\r\n\r\n            element.attr('aria-expanded', true);\r\n\r\n            //Select the single remaining option if user input matches\r\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\r\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\r\n                $$debounce(function() {\r\n                  scope.select(0, evt);\r\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\r\n              } else {\r\n                scope.select(0, evt);\r\n              }\r\n            }\r\n\r\n            if (showHint) {\r\n              var firstLabel = scope.matches[0].label;\r\n              if (angular.isString(inputValue) &&\r\n                inputValue.length > 0 &&\r\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\r\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\r\n              } else {\r\n                hintInputElem.val('');\r\n              }\r\n            }\r\n          } else {\r\n            resetMatches();\r\n            isNoResultsSetter(originalScope, true);\r\n          }\r\n        }\r\n        if (onCurrentRequest) {\r\n          isLoadingSetter(originalScope, false);\r\n        }\r\n      }, function() {\r\n        resetMatches();\r\n        isLoadingSetter(originalScope, false);\r\n        isNoResultsSetter(originalScope, true);\r\n      });\r\n    };\r\n\r\n    // bind events only if appendToBody params exist - performance feature\r\n    if (appendToBody) {\r\n      angular.element($window).on('resize', fireRecalculating);\r\n      $document.find('body').on('scroll', fireRecalculating);\r\n    }\r\n\r\n    // Declare the debounced function outside recalculating for\r\n    // proper debouncing\r\n    var debouncedRecalculate = $$debounce(function() {\r\n      // if popup is visible\r\n      if (scope.matches.length) {\r\n        recalculatePosition();\r\n      }\r\n\r\n      scope.moveInProgress = false;\r\n    }, eventDebounceTime);\r\n\r\n    // Default progress type\r\n    scope.moveInProgress = false;\r\n\r\n    function fireRecalculating() {\r\n      if (!scope.moveInProgress) {\r\n        scope.moveInProgress = true;\r\n        scope.$digest();\r\n      }\r\n\r\n      debouncedRecalculate();\r\n    }\r\n\r\n    // recalculate actual position and set new values to scope\r\n    // after digest loop is popup in right position\r\n    function recalculatePosition() {\r\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\r\n      scope.position.top += element.prop('offsetHeight');\r\n    }\r\n\r\n    //we need to propagate user's query so we can higlight matches\r\n    scope.query = undefined;\r\n\r\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\r\n    var timeoutPromise;\r\n\r\n    var scheduleSearchWithTimeout = function(inputValue) {\r\n      timeoutPromise = $timeout(function() {\r\n        getMatchesAsync(inputValue);\r\n      }, waitTime);\r\n    };\r\n\r\n    var cancelPreviousTimeout = function() {\r\n      if (timeoutPromise) {\r\n        $timeout.cancel(timeoutPromise);\r\n      }\r\n    };\r\n\r\n    resetMatches();\r\n\r\n    scope.assignIsOpen = function (isOpen) {\r\n      isOpenSetter(originalScope, isOpen);\r\n    };\r\n\r\n    scope.select = function(activeIdx, evt) {\r\n      //called from within the $digest() cycle\r\n      var locals = {};\r\n      var model, item;\r\n\r\n      selected = true;\r\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\r\n      model = parserResult.modelMapper(originalScope, locals);\r\n      $setModelValue(originalScope, model);\r\n      modelCtrl.$setValidity('editable', true);\r\n      modelCtrl.$setValidity('parse', true);\r\n\r\n      onSelectCallback(originalScope, {\r\n        $item: item,\r\n        $model: model,\r\n        $label: parserResult.viewMapper(originalScope, locals),\r\n        $event: evt\r\n      });\r\n\r\n      resetMatches();\r\n\r\n      //return focus to the input element if a match was selected via a mouse click event\r\n      // use timeout to avoid $rootScope:inprog error\r\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\r\n        $timeout(function() { element[0].focus(); }, 0, false);\r\n      }\r\n    };\r\n\r\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\r\n    element.on('keydown', function(evt) {\r\n      //typeahead is open and an \"interesting\" key was pressed\r\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\r\n        return;\r\n      }\r\n\r\n      var shouldSelect = isSelectEvent(originalScope, {$event: evt});\r\n\r\n      /**\r\n       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\r\n       * or\r\n       * shift + tab is pressed to bring focus to the previous element\r\n       * then clear the results\r\n       */\r\n      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {\r\n        resetMatches();\r\n        scope.$digest();\r\n        return;\r\n      }\r\n\r\n      evt.preventDefault();\r\n      var target;\r\n      switch (evt.which) {\r\n        case 27: // escape\r\n          evt.stopPropagation();\r\n\r\n          resetMatches();\r\n          originalScope.$digest();\r\n          break;\r\n        case 38: // up arrow\r\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\r\n          scope.$digest();\r\n          target = popUpEl.find('li')[scope.activeIdx];\r\n          target.parentNode.scrollTop = target.offsetTop;\r\n          break;\r\n        case 40: // down arrow\r\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\r\n          scope.$digest();\r\n          target = popUpEl.find('li')[scope.activeIdx];\r\n          target.parentNode.scrollTop = target.offsetTop;\r\n          break;\r\n        default:\r\n          if (shouldSelect) {\r\n            scope.$apply(function() {\r\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\r\n                $$debounce(function() {\r\n                  scope.select(scope.activeIdx, evt);\r\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\r\n              } else {\r\n                scope.select(scope.activeIdx, evt);\r\n              }\r\n            });\r\n          }\r\n      }\r\n    });\r\n\r\n    element.bind('focus', function (evt) {\r\n      hasFocus = true;\r\n      if (minLength === 0 && !modelCtrl.$viewValue) {\r\n        $timeout(function() {\r\n          getMatchesAsync(modelCtrl.$viewValue, evt);\r\n        }, 0);\r\n      }\r\n    });\r\n\r\n    element.bind('blur', function(evt) {\r\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\r\n        selected = true;\r\n        scope.$apply(function() {\r\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\r\n            $$debounce(function() {\r\n              scope.select(scope.activeIdx, evt);\r\n            }, scope.debounceUpdate.blur);\r\n          } else {\r\n            scope.select(scope.activeIdx, evt);\r\n          }\r\n        });\r\n      }\r\n      if (!isEditable && modelCtrl.$error.editable) {\r\n        modelCtrl.$setViewValue();\r\n        // Reset validity as we are clearing\r\n        modelCtrl.$setValidity('editable', true);\r\n        modelCtrl.$setValidity('parse', true);\r\n        element.val('');\r\n      }\r\n      hasFocus = false;\r\n      selected = false;\r\n    });\r\n\r\n    // Keep reference to click handler to unbind it.\r\n    var dismissClickHandler = function(evt) {\r\n      // Issue #3973\r\n      // Firefox treats right click as a click on document\r\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\r\n        resetMatches();\r\n        if (!$rootScope.$$phase) {\r\n          originalScope.$digest();\r\n        }\r\n      }\r\n    };\r\n\r\n    $document.on('click', dismissClickHandler);\r\n\r\n    originalScope.$on('$destroy', function() {\r\n      $document.off('click', dismissClickHandler);\r\n      if (appendToBody || appendTo) {\r\n        $popup.remove();\r\n      }\r\n\r\n      if (appendToBody) {\r\n        angular.element($window).off('resize', fireRecalculating);\r\n        $document.find('body').off('scroll', fireRecalculating);\r\n      }\r\n      // Prevent jQuery cache memory leak\r\n      popUpEl.remove();\r\n\r\n      if (showHint) {\r\n          inputsContainer.remove();\r\n      }\r\n    });\r\n\r\n    var $popup = $compile(popUpEl)(scope);\r\n\r\n    if (appendToBody) {\r\n      $document.find('body').append($popup);\r\n    } else if (appendTo) {\r\n      angular.element(appendTo).eq(0).append($popup);\r\n    } else {\r\n      element.after($popup);\r\n    }\r\n\r\n    this.init = function(_modelCtrl, _ngModelOptions) {\r\n      modelCtrl = _modelCtrl;\r\n      ngModelOptions = _ngModelOptions;\r\n\r\n      scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);\r\n\r\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\r\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\r\n      modelCtrl.$parsers.unshift(function(inputValue) {\r\n        hasFocus = true;\r\n\r\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\r\n          if (waitTime > 0) {\r\n            cancelPreviousTimeout();\r\n            scheduleSearchWithTimeout(inputValue);\r\n          } else {\r\n            getMatchesAsync(inputValue);\r\n          }\r\n        } else {\r\n          isLoadingSetter(originalScope, false);\r\n          cancelPreviousTimeout();\r\n          resetMatches();\r\n        }\r\n\r\n        if (isEditable) {\r\n          return inputValue;\r\n        }\r\n\r\n        if (!inputValue) {\r\n          // Reset in case user had typed something previously.\r\n          modelCtrl.$setValidity('editable', true);\r\n          return null;\r\n        }\r\n\r\n        modelCtrl.$setValidity('editable', false);\r\n        return undefined;\r\n      });\r\n\r\n      modelCtrl.$formatters.push(function(modelValue) {\r\n        var candidateViewValue, emptyViewValue;\r\n        var locals = {};\r\n\r\n        // The validity may be set to false via $parsers (see above) if\r\n        // the model is restricted to selected values. If the model\r\n        // is set manually it is considered to be valid.\r\n        if (!isEditable) {\r\n          modelCtrl.$setValidity('editable', true);\r\n        }\r\n\r\n        if (inputFormatter) {\r\n          locals.$model = modelValue;\r\n          return inputFormatter(originalScope, locals);\r\n        }\r\n\r\n        //it might happen that we don't have enough info to properly render input value\r\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\r\n        locals[parserResult.itemName] = modelValue;\r\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\r\n        locals[parserResult.itemName] = undefined;\r\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\r\n\r\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\r\n      });\r\n    };\r\n  }])\r\n\r\n  .directive('uibTypeahead', function() {\r\n    return {\r\n      controller: 'UibTypeaheadController',\r\n      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],\r\n      link: function(originalScope, element, attrs, ctrls) {\r\n        ctrls[2].init(ctrls[0], ctrls[1]);\r\n      }\r\n    };\r\n  })\r\n\r\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\r\n    return {\r\n      scope: {\r\n        matches: '=',\r\n        query: '=',\r\n        active: '=',\r\n        position: '&',\r\n        moveInProgress: '=',\r\n        select: '&',\r\n        assignIsOpen: '&',\r\n        debounce: '&'\r\n      },\r\n      replace: true,\r\n      templateUrl: function(element, attrs) {\r\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\r\n      },\r\n      link: function(scope, element, attrs) {\r\n        scope.templateUrl = attrs.templateUrl;\r\n\r\n        scope.isOpen = function() {\r\n          var isDropdownOpen = scope.matches.length > 0;\r\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\r\n          return isDropdownOpen;\r\n        };\r\n\r\n        scope.isActive = function(matchIdx) {\r\n          return scope.active === matchIdx;\r\n        };\r\n\r\n        scope.selectActive = function(matchIdx) {\r\n          scope.active = matchIdx;\r\n        };\r\n\r\n        scope.selectMatch = function(activeIdx, evt) {\r\n          var debounce = scope.debounce();\r\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\r\n            $$debounce(function() {\r\n              scope.select({activeIdx: activeIdx, evt: evt});\r\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\r\n          } else {\r\n            scope.select({activeIdx: activeIdx, evt: evt});\r\n          }\r\n        };\r\n      }\r\n    };\r\n  }])\r\n\r\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\r\n    return {\r\n      scope: {\r\n        index: '=',\r\n        match: '=',\r\n        query: '='\r\n      },\r\n      link: function(scope, element, attrs) {\r\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\r\n        $templateRequest(tplUrl).then(function(tplContent) {\r\n          var tplEl = angular.element(tplContent.trim());\r\n          element.replaceWith(tplEl);\r\n          $compile(tplEl)(scope);\r\n        });\r\n      }\r\n    };\r\n  }])\r\n\r\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\r\n    var isSanitizePresent;\r\n    isSanitizePresent = $injector.has('$sanitize');\r\n\r\n    function escapeRegexp(queryToEscape) {\r\n      // Regex: capture the whole query string and replace it with the string that will be used to match\r\n      // the results, for example if the capture is \"a\" the result will be \\a\r\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\r\n    }\r\n\r\n    function containsHtml(matchItem) {\r\n      return /<.*>/g.test(matchItem);\r\n    }\r\n\r\n    return function(matchItem, query) {\r\n      if (!isSanitizePresent && containsHtml(matchItem)) {\r\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\r\n      }\r\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\r\n      if (!isSanitizePresent) {\r\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\r\n      }\r\n      return matchItem;\r\n    };\r\n  }]);\r\n\r\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\r\n    \"<div class=\\\"panel\\\" ng-class=\\\"panelClass || 'panel-default'\\\">\\n\" +\r\n    \"  <div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\r\n    \"    <h4 class=\\\"panel-title\\\">\\n\" +\r\n    \"      <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\"><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\r\n    \"    </h4>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"  <div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\r\n    \"    <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\r\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\r\n}]);\r\n\r\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/alert/alert.html\",\r\n    \"<div class=\\\"alert\\\" ng-class=\\\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\\\" role=\\\"alert\\\">\\n\" +\r\n    \"    <button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\r\n    \"        <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\r\n    \"        <span class=\\\"sr-only\\\">Close</span>\\n\" +\r\n    \"    </button>\\n\" +\r\n    \"    <div ng-transclude></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\r\n    \"<div ng-mouseenter=\\\"pause()\\\" ng-mouseleave=\\\"play()\\\" class=\\\"carousel\\\" ng-swipe-right=\\\"prev()\\\" ng-swipe-left=\\\"next()\\\">\\n\" +\r\n    \"  <div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\r\n    \"  <a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-class=\\\"{ disabled: isPrevDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\r\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\r\n    \"    <span class=\\\"sr-only\\\">previous</span>\\n\" +\r\n    \"  </a>\\n\" +\r\n    \"  <a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-class=\\\"{ disabled: isNextDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\r\n    \"    <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\r\n    \"    <span class=\\\"sr-only\\\">next</span>\\n\" +\r\n    \"  </a>\\n\" +\r\n    \"  <ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\r\n    \"    <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\r\n    \"      <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\r\n    \"    </li>\\n\" +\r\n    \"  </ol>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/carousel/slide.html\",\r\n    \"<div ng-class=\\\"{\\n\" +\r\n    \"    'active': active\\n\" +\r\n    \"  }\\\" class=\\\"item text-center\\\" ng-transclude></div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\r\n    \"<div class=\\\"uib-datepicker\\\" ng-switch=\\\"datepickerMode\\\" role=\\\"application\\\" ng-keydown=\\\"keydown($event)\\\">\\n\" +\r\n    \"  <uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\"></uib-daypicker>\\n\" +\r\n    \"  <uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\"></uib-monthpicker>\\n\" +\r\n    \"  <uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\"></uib-yearpicker>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/datepicker/day.html\",\r\n    \"<table class=\\\"uib-daypicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\r\n    \"  <thead>\\n\" +\r\n    \"    <tr>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\r\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"    <tr>\\n\" +\r\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\r\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </thead>\\n\" +\r\n    \"  <tbody>\\n\" +\r\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\r\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\r\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\r\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\r\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\r\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\r\n    \"          uib-is-class=\\\"\\n\" +\r\n    \"            'btn-info' for selectedDt,\\n\" +\r\n    \"            'active' for activeDt\\n\" +\r\n    \"            on dt\\\"\\n\" +\r\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\r\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\r\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </tbody>\\n\" +\r\n    \"</table>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/datepicker/month.html\",\r\n    \"<table class=\\\"uib-monthpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\r\n    \"  <thead>\\n\" +\r\n    \"    <tr>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\r\n    \"      <th><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </thead>\\n\" +\r\n    \"  <tbody>\\n\" +\r\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\r\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\r\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\r\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\r\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\r\n    \"          uib-is-class=\\\"\\n\" +\r\n    \"            'btn-info' for selectedDt,\\n\" +\r\n    \"            'active' for activeDt\\n\" +\r\n    \"            on dt\\\"\\n\" +\r\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\r\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\r\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </tbody>\\n\" +\r\n    \"</table>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/datepicker/year.html\",\r\n    \"<table class=\\\"uib-yearpicker\\\" role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\r\n    \"  <thead>\\n\" +\r\n    \"    <tr>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-left\\\"></i></button></th>\\n\" +\r\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\r\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i class=\\\"glyphicon glyphicon-chevron-right\\\"></i></button></th>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </thead>\\n\" +\r\n    \"  <tbody>\\n\" +\r\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\">\\n\" +\r\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\r\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\r\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\r\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\r\n    \"          uib-is-class=\\\"\\n\" +\r\n    \"            'btn-info' for selectedDt,\\n\" +\r\n    \"            'active' for activeDt\\n\" +\r\n    \"            on dt\\\"\\n\" +\r\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\r\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\r\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </tbody>\\n\" +\r\n    \"</table>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/datepickerPopup/popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/datepickerPopup/popup.html\",\r\n    \"<div>\\n\" +\r\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\r\n    \"    <li ng-transclude></li>\\n\" +\r\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\r\n    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\r\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\r\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\r\n    \"      </span>\\n\" +\r\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\r\n    \"    </li>\\n\" +\r\n    \"  </ul>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\r\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\r\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\r\n    \"     modal-in-class=\\\"in\\\"\\n\" +\r\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\r\n    \"></div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/modal/window.html\",\r\n    \"<div modal-render=\\\"{{$isRendered}}\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\" class=\\\"modal\\\"\\n\" +\r\n    \"    uib-modal-animation-class=\\\"fade\\\"\\n\" +\r\n    \"    modal-in-class=\\\"in\\\"\\n\" +\r\n    \"    ng-style=\\\"{'z-index': 1050 + index*10, display: 'block'}\\\">\\n\" +\r\n    \"    <div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/pager/pager.html\",\r\n    \"<ul class=\\\"pager\\\">\\n\" +\r\n    \"  <li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\r\n    \"  <li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\r\n    \"</ul>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\r\n    \"<ul class=\\\"pagination\\\">\\n\" +\r\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\">{{::getText('first')}}</a></li>\\n\" +\r\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\">{{::getText('previous')}}</a></li>\\n\" +\r\n    \"  <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\">{{page.text}}</a></li>\\n\" +\r\n    \"  <li ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\">{{::getText('next')}}</a></li>\\n\" +\r\n    \"  <li ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\">{{::getText('last')}}</a></li>\\n\" +\r\n    \"</ul>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\r\n    \"<div class=\\\"tooltip\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\r\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\r\n    \"<div class=\\\"tooltip\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\r\n    \"  <div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\r\n    \"<div class=\\\"tooltip\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"tooltip-arrow\\\"></div>\\n\" +\r\n    \"  <div class=\\\"tooltip-inner\\\"\\n\" +\r\n    \"    uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\r\n    \"    tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\r\n    \"<div class=\\\"popover\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\r\n    \"\\n\" +\r\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\r\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\r\n    \"      <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\r\n    \"<div class=\\\"popover\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\r\n    \"\\n\" +\r\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\r\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\r\n    \"      <div class=\\\"popover-content\\\"\\n\" +\r\n    \"        uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\r\n    \"        tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/popover/popover.html\",\r\n    \"<div class=\\\"popover\\\"\\n\" +\r\n    \"  tooltip-animation-class=\\\"fade\\\"\\n\" +\r\n    \"  uib-tooltip-classes\\n\" +\r\n    \"  ng-class=\\\"{ in: isOpen() }\\\">\\n\" +\r\n    \"  <div class=\\\"arrow\\\"></div>\\n\" +\r\n    \"\\n\" +\r\n    \"  <div class=\\\"popover-inner\\\">\\n\" +\r\n    \"      <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\r\n    \"      <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\r\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\r\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\r\n}]);\r\n\r\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\r\n    \"<div class=\\\"progress\\\">\\n\" +\r\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/rating/rating.html\",\r\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuetext=\\\"{{title}}\\\">\\n\" +\r\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\r\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\"></i>\\n\" +\r\n    \"</span>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/tabs/tab.html\",\r\n    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\r\n    \"  <a href ng-click=\\\"select($event)\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\r\n    \"</li>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\r\n    \"<div>\\n\" +\r\n    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\r\n    \"  <div class=\\\"tab-content\\\">\\n\" +\r\n    \"    <div class=\\\"tab-pane\\\"\\n\" +\r\n    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\r\n    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\r\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\r\n    \"    </div>\\n\" +\r\n    \"  </div>\\n\" +\r\n    \"</div>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\r\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\r\n    \"  <tbody>\\n\" +\r\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\r\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\r\n    \"      <td>&nbsp;</td>\\n\" +\r\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\r\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\r\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\r\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"    <tr>\\n\" +\r\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\r\n    \"        <input type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\r\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\r\n    \"        <input type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\r\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\r\n    \"        <input type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\r\n    \"      </td>\\n\" +\r\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\r\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\r\n    \"      <td>&nbsp;</td>\\n\" +\r\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\r\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\r\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"{{::tabindex}}\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\r\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\r\n    \"    </tr>\\n\" +\r\n    \"  </tbody>\\n\" +\r\n    \"</table>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\r\n    \"<a href\\n\" +\r\n    \"   tabindex=\\\"-1\\\"\\n\" +\r\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\r\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\r\n    \"\");\r\n}]);\r\n\r\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function($templateCache) {\r\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\r\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\r\n    \"    <li ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\r\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\r\n    \"    </li>\\n\" +\r\n    \"</ul>\\n\" +\r\n    \"\");\r\n}]);\r\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });\r\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });\r\nangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });\r\nangular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });\r\nangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });\r\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });\r\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });"],"file":"ui-bootstrap-tpls.js","sourceRoot":"/source/"}